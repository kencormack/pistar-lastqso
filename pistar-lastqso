#!/bin/bash
# pistar-lastqso
# Written by:   Ken Cormack (KE8DPF), unixken@yahoo.com
# Copyright Â© 2022, Ken Cormack
# github:       https://github.com/kencormack/pistar-lastqso
# QRZ page:     https://www.qrz.com/db/KE8DPF

###########################################################
# INITIALIZATION
###########################################################

set -o allexport

VERSION=2.35

#----------
#===============
if [[ "${EUID}" -eq 0 ]]
then
  echo
  echo "ERROR:" >&2
  echo "  Execution directly by \"root\" not required." >&2
  echo "  Please run with the normal \"pi-star\" userid." >&2
  echo
  exit
fi

#===============
# NOTE #1: Originally written for pi-star >= 4.1.4, for DMR mode ONLY.
# Support for YSF (plus DMR2YSF and YSF2DMR) was added later.  If the
# log structure changes in any way with future releases of pi-star, or
# if you want to display modes other than DMR and YSF (D-Star, P25, etc.)
# you will need to modify this script accordingly.  I developed this
# first for DMR, using a TYT MD-UV390GPS.  I later obtained a Yaesu
# FT-70DR and added support for YSF.  If someone would like to gift me
# an ICOM ID52A or similar HT, I'd be happy to add D-Star.  Same goes
# for the other modes. ;)

# NOTE #2: I've tried to write this script with readability in mind.
# A year after having last touched a script, I like to look at it and
# quickly understand what it's doing, without a lot of head scratching.
# Comments are applied liberally, throughout, and "clever but cryptic"
# one-liners that are not immediately understandable without reading
# (and then re-reading) various man pages, are generally avoided.  The
# priority is understandability, rather than clever elegance or raw
# performance, within reason.

# NOTE #3: I cut my teeth on Sequent hardware and SVR3, 30+ years ago.
# At heart, I'm a KSH guy.  Consequently, you may find "old fashioned"
# ksh-like syntax in here (out of habbit), where a "modern"(?) bash-ism
# might exist, but that I simply forgot to use.

#===============
# NOTES ON GETTING RID OF SOME CUTS
#${var#*SubStr}  # drops substring from start of string up to first occurrence of `SubStr`
#${var##*SubStr} # drops substring from start of string up to last occurrence of `SubStr`
#${var%SubStr*}  # drops substring from last occurrence of `SubStr` to end of string
#${var%%SubStr*} # drops substring from first occurrence of `SubStr` to end of string
#     VAR="${VAR#*=}"		same as:  cut -f2 -d"="
#     VAR="${VAR%,*}"		same as:  cut -f1 -d","
# If a string contains multiple fields, these do not extract *just* a single "hit".
#
# For that, make use of an array...
#     IFS='/'; CUT_ARRAY=(${STRING TO PICK APART}); unset IFS;  #IFS is the field separator
#     SPECIFIC_NEEDED_DATA="${CUT_ARRAY[0]}"                  #[0] is first field, [1] is second, [2] is third, etc.
#     unset CUT_ARRAY
# This allows selection of a single field, without contaminating that field with
# overlap from another field

#===============
# For whatever reason, "umask 0077" isn't locking down permissions
# on files written to /tmp, the way symbolically setting it does.
# I'll need to look into that a bit more.
umask u=rw,g=,o=

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

# Start the Elapsed Time clock
SECONDS=0

# For the -i|--info section
MY_PID="$(pgrep -o -f "/bin/bash /usr/local/bin/pistar-lastqso")"

#===============
# For bash's built-in "time" command
# This gives us just the "real" time,
# in seconds, for the "time" command
# that clocks dxcc.pl execution time.
TIMEFORMAT='%R'

#===============
# Any equal signs passed on the cmdline are replaced w/ spaces,
# so that an option, and it's parameter (if any), are two separate
# elements in an array.  The array gets passed to fnPARSE_CMDLINE.
#
# Gather what's passed on the cmdline...
# Strip any "=" signs separating an option and it's parameter...
# Place the groomed elements into an array
MY_CMDLINE="${*//=/ }"
read -r -a ARG_LIST <<< "${MY_CMDLINE}"
ARG_LIST_LENGTH=${#ARG_LIST[@]}

#===============
# Get the full path to this script
# shellcheck disable=SC2034
SCRIPT="$(readlink -f "${0}")"

#===============
# Get the tty we're using.  Tmp files will be suffixed to keep
# multiple concurrent sessions from stomping on each other's files.
MY_TTY="$(tty | sed -u -e 's/\///g' -e 's/dev//')"

#===============
# Turn on privileged mode. In this mode, the $BASH_ENV and $ENV files
# are not processed, shell functions are not inherited from the
# environment, and the SHELLOPTS, BASHOPTS, CDPATH and GLOBIGNORE
# variables, if they appear in the environment, are ignored.
set -p
# Make globs that don't get expanded cause errors, rather than getting
# passed to the command with the * intact.
shopt -s failglob
# Ensure that ERR traps are inherited by functions, command substitutions,
# and subshell environments.
set -o errtrace
# Ensure that DEBUG and RETURN traps are inherited by functions, command substitutions,
# and subshell environments.  (The -E causes errors within functions to bubble up.)
set -E -o functrace

#===============
# SET UP THE DEBUG FILE DESCRIPTOR
# If it doesn't already exist, setup the file descriptor for debugging
[[ -e /proc/self/fd/3 ]] || exec 3> /dev/null
# If no redirection has been applied by the user, "${DEBUG_LOG}" will be "/dev/null".
# But if the user has redirected fd 3 to a file, then "${DEBUG_LOG}" will contain the
# name (with full path), to the file.
DEBUG_LOG="$(readlink /proc/self/fd/3 2>/dev/null)"
echo "LASTQSO v${VERSION} - DEBUGGING LOG" >&3
echo -e "==================================\n" >&3
# FOR DEBUGGING: THE DEBUG TRAP
# This trap writes each line to be executed, just before it is executed, to the debug log.
trap 'echo -e "line#: ${LINENO}...\t${BASH_COMMAND}" >&3' DEBUG
# FOR DEBUGGING: THE ERR TRAP
# This trap will log all non-0 return codes.
trap 'echo -e "NON-0: LINE ${LINENO}: RETURN CODE: ${?}\t${BASH_COMMAND}" >&3' ERR
# FOR DEBUGGING: THE RETURN TRAP
# This trap logs the completion of each function, upon return.
trap 'echo -e "leave: ${FUNCNAME} -> back to ${FUNCNAME[1]}\n" >&3' RETURN

#===============
# SET UP THE PROFILING FILE DESCRIPTOR
# For a rough profiling of this script
[[ -e /proc/self/fd/4 ]] || exec 4> /dev/null
# If no redirection has been applied by the user, "${PROFILING_LOG}" will be "/dev/null".
# But if the user has redirected fd 4 to a file, then "${PROFILING_LOG}" will contain the
# name (with full path), to the file.
PROFILING_LOG="$(readlink /proc/self/fd/4 2>/dev/null)"
echo "LASTQSO v${VERSION} - PROFILING LOG" >&4
echo -e "==================================\n" >&4
BASH_XTRACEFD="4"
# Using PS4, "\011" is a tab, and "\t" is a current hh:mm:ss timestamp
# (I don't need subsecond accuracy here.)
PS4='+\011\t ${LINENO}\011'
# Enclose any section of code we want to profile with "set -x"..."set +x".
# Profiling data will be sent to the fd whenever "set -x" is in effect.
# Turning it on now, for example, would basically profile everything from
# here down.  Use sparingly, as it can seriously impact performance
# (and don't forget to turn it off when done).
# set -x

#===============
# Defaults that can be overridden with cmdline options...
#
# Don't force immediate download of user.csv file.
# Can be overridden with "-c|--csv" cmdline option
GET_CSV_NOW=0
#
# Don't force immediate download of cty.dat file.
# Can be overridden with "-d|--dat" cmdline option
GET_DAT_NOW=0
#
# Call upon dxcc.pl to resolve YSF QTH country when
# the callsign can't be found in either the DMR
# user.csv or NXDN NXDN.csv files.  Can be overridden
# with "-D|--DXCC" cmdline option.
USE_DXCC=1
#
# Show errors as they appear in the MMDVM log.
# Can be overridden with "-e|--errors" cmdline option
SHOW_LOG_ERRORS=1
#
# *IF* your display is greater than 130 columns wide,
# *AND* you use the "-t|--top" option, *AND* you add
# the "-i|--info" option, a few helpful details are
# added to the top-right corner of the display.  This
# is helpful if you are modifying this script.  Other
# than that, it serves little use.
SHOW_DEV_INFO=0
#
# Display Callsigns & TGs/DG-IDs in large font.
# Can be overridden with "-n|--nobig" cmdline option
USE_BANNER=1
#
# Allow figlet to auto-wrap as needed.
# Can be overridden with "-w|--wrap" cmdline option
NO_WRAP=0
#
# Don't display the config and history section at top of screen.
# Can be overridden with "-t|--top" cmdline option
TOP=0
#
# By default, display logo screen.
# Can be disabled with "-l|--logo" cmdline option
LOGO=1
#
#KPC
# By default, the script will parse the current "live" log
# using "tail".  But if testing, this option will use the
# "cat" command instead, to replay a user-specified log.
REPLAY=0

#===============
# Define some ways to make things bold, use different colors, control
# scrolling and cursor positioning, and so on.  See "man tput" for
# descriptions of each tput parameter used here.  (tput is much more
# predictable across terminal types than cryptic ANSI escape sequences.)
BELL="$(tput bel)"		# Sound a bell
FLASH="$(tput flash)"		# Flash the screen

# Not all term types (including the pi console's "TERM=linux") support
# tput's alternate screen buffers.  If not, just clear the screen.
if infocmp -1 | grep -q "smcup=" && infocmp -1 | grep -q "rmcup="
then
  SMCUP="$(tput smcup)"		# Set alternate screen buffer
  RMCUP="$(tput rmcup)"		# Restore primary screen buffer
  HAS_BUFFER=1
else
  SMCUP="$(tput clear)"
  RMCUP="$(tput clear)"
  HAS_BUFFER=0
fi

CUR_HOME=$(tput cup 0 0)	# Send the cursor home, to line 0, column 0

CUR_SC="$(tput sc)"		# Save cursor position
CUR_RC="$(tput rc)"		# Restore cursor position

CUR_OFF="$(tput civis)"		# Turn cursor off
CUR_ON="$(tput cnorm)"		# Turn cursor on

CLR_EL="$(tput el)"		# Clear to end of line
CLR_ED="$(tput ed)"		# Clear to end of display

INS_LINE="$(tput il1)"		# Insert a line above current row (pushes everything down)
#DEL_LINE="$(tput dl1)"		# Delete a line below current row (pulls everything up)

SGR0="$(tput sgr0)"		# Undo text attributes (bold, etc.)
BOLD="$(tput bold)"		# Make text bold
DIM="$(tput dim)"		# Half-intensity
REV="$(tput rev)"		# Reverse text fg/bg colors
SMUL="$(tput smul)"		# Start Underline text
RMUL="$(tput rmul)"		# End Underline text
#BLINK="$(tput blink)"		# Blink text

CUR_UP="$(tput cuu1)"		# Cursor up, one line
#CUR_DN="$(tput cud1)"		# Cursor down, one line

WRAP_OFF="$(tput rmam)"		# Disable line-wrap
WRAP_ON="$(tput smam)"		# Enable line-wrap

# Forground colors
BLA="$(tput setaf 0)"		# Black
RED="$(tput setaf 1)"		# Red
GRE="$(tput setaf 2)"		# Green
YEL="$(tput setaf 3)"		# Yellow
BLU="$(tput setaf 4)"		# Blue
MAG="$(tput setaf 5)"		# Magenta
CYA="$(tput setaf 6)"		# Cyan
WHI="$(tput setaf 7)"		# White
DEF="$(tput setaf 9)"		# Default

# Background colors
# Reserved for possible future use
# BG_BLA="$(tput setab 0)"	# Black
# BG_RED="$(tput setab 1)"	# Red
# BG_GRE="$(tput setab 2)"	# Green
# BG_YEL="$(tput setab 3)"	# Yellow
# BG_BLU="$(tput setab 4)"	# Blue
# BG_MAG="$(tput setab 5)"	# Magenta
# BG_CYA="$(tput setab 6)"	# Cyan
# BG_WHI="$(tput setab 7)"	# White
# BG_DEF="$(tput setab 9)"	# Default

#===============
# ANSI STUFF - for things that tput can't address.
# Not every terminal emulator or term type may support ANSI
# escape sequences, though most common ones do.  YMMV
#
# The ESCape character
ESC=$(echo -n $'\e' 2>/dev/null)
#
# "tput sgr0" fails to restore terminal settings under certain
# circumstances.  This may(?) be a better choice, upon exit.
TERM_RESET="$(echo -ne "${ESC}[0m" 2>/dev/null)"
#
# Wide character set
# 6 sets line double-width, with normal height
# shellcheck disable=SC2034
WIDE_FONT="$(echo -n "${ESC}"#6 2>/dev/null)"
# 5 sets line single-width (lines are set this way when cleared by ESC [ J)
# shellcheck disable=SC2034
NORM_FONT="$(echo -n "${ESC}"#5 2>/dev/null)"
#
# Double-height, double-width character set.
# 3 is top half of charset, 4 is bottom half.
# Not every terminal type/emulation supports these.
LARGE_TOP="$(echo -n "${ESC}#3" 2>/dev/null)"
LARGE_BOT="$(echo -n "${ESC}#4" 2>/dev/null)"

#===============
# Stuff deaaling with pi-star files
#
#MY_CALLSIGN="$(grep -A 8 "^\[General\]" /etc/mmdvmhost | grep "^Enable")"
#MY_CALLSIGN="${MY_CALLSIGN#*=}"

# Some DMR-related files we'll be consulting...
# These are supplied with, and updated by, pistar
#DMRIDS="$(grep -A 2 "^\[DMR Id Lookup\]" /etc/mmdvmhost | grep "^File" | cut -f2 -d"=")"
DMRIDS="$(grep -A 2 "^\[DMR Id Lookup\]" /etc/mmdvmhost | grep "^File")"
DMRIDS="${DMRIDS#*=}"

TGLIST="$(grep "^TGLISTBM=" /usr/local/sbin/HostFilesUpdate.sh)"
TGLIST="${TGLIST#*=}"

# Unlike the two files above, all of pi-star's references to this file are
# hard-coded, so I am safe to set this varible directly to the filename.
DMRHOSTS=/usr/local/etc/DMR_Hosts.txt

# Users can create this next file to contain any DMR talkgroup
# names that are blank/empty in the pistar-supplied TGLIST above.
# If all your talk groups are covered, then you don't need to
# worry about this file.
MY_LIST=/usr/local/etc/MY_LIST.txt

# This is the master DMR user.csv file from radioid.net.
# We download this, and update it if older than 7 days.
USERCSV=/usr/local/etc/user.csv

# This is the NXDN.csv file supplied with, and updated by pi-star.
# It is identical in structure to the DMR user.csv file
NXDNCSV=/usr/local/etc/NXDN.csv

# This is the cty.dat file from www.country-files.com.
# It is used by dxcc.pl, to determine the country that issued
# a callsign, based on the callsign's prefix.  We download
# and update it if older than 30 days.
CTYDAT=/usr/local/etc/cty.dat

#KPC
#===============
if [[ ${REPLAY} -eq 1 ]]
then
  WORKING_LOG="${REPLAY_LOG}"
else
  # Find the latest log
  LOGDIR="$(grep -A 4 "^\[Log\]" /etc/mmdvmhost | grep "^FilePath=")"
  LOGDIR="${LOGDIR#*=}"

  LOGROOT="$(grep -A 4 "^\[Log\]" /etc/mmdvmhost | grep "^FileRoot=")"
  LOGROOT="${LOGROOT#*=}"

  CANDIDATE_FILES=("${LOGDIR}/${LOGROOT}"*.log) NEWEST=${CANDIDATE_FILES[0]}
  for F in "${CANDIDATE_FILES[@]}"
  do
    if [[ "${F}" -nt "${NEWEST}" ]]
    then
      NEWEST="${F}"
    fi
  done
  WORKING_LOG="${NEWEST}"
fi

#===============
# APIKEY="$(grep "^apikey=" /etc/bmapi.key 2>/dev/null | cut -f2 -d"=")"
# APIKEY="$(grep "^apikey=" /etc/bmapi.key 2>/dev/null)"
# APIKEY="${APIKEY#*=}"
HOTSPOT_ID="$(grep -A 13 "^\[DMR\]" /etc/mmdvmhost | grep "^Id=")"
HOTSPOT_ID="${HOTSPOT_ID#*=}"

#===============
# All these tmpfiles preserve the counters manipulated in sub-process/
# sub-shells, and in functions and loops, that are needed by (but not
# otherwise "handed up" to) the parent shell.
DMR_COUNT_FILE="/tmp/lastqso-dmr-${MY_TTY}"
YSF_COUNT_FILE="/tmp/lastqso-ysf-${MY_TTY}"
QSO_COUNT_FILE="/tmp/lastqso-qso-${MY_TTY}"
KERCHUNK_COUNT_FILE="/tmp/lastqso-kerchunk-${MY_TTY}"
ERROR_COUNT_FILE="/tmp/lastqso-error-${MY_TTY}"
WARNING_COUNT_FILE="/tmp/lastqso-warning-${MY_TTY}"
for FILE in "${DMR_COUNT_FILE}" "${YSF_COUNT_FILE}" "${QSO_COUNT_FILE}" "${KERCHUNK_COUNT_FILE}" "${ERROR_COUNT_FILE}" "${WARNING_COUNT_FILE}"
do
  echo "0" > "${FILE}"
done
# Initialize all the counters to zero
DMR_COUNT=$(< "${DMR_COUNT_FILE}")
YSF_COUNT=$(< "${YSF_COUNT_FILE}")
QSO_COUNT=$(< "${QSO_COUNT_FILE}")
KERCHUNK_COUNT=$(< "${KERCHUNK_COUNT_FILE}")
ERROR_COUNT=$(< "${ERROR_COUNT_FILE}")
WARNING_COUNT=$(< "${WARNING_COUNT_FILE}")
LOG_RESTARTS=0

HISTORY_FILE="/tmp/lastqso-history-${MY_TTY}"

# When we query Brandmeister to learn a hotspot's statically
# linked TGs, the findings are written to this tmpfile.
STATIC_TG_FILE="/tmp/lastqso-static-${MY_TTY}"

# When dxcc.pl is called to find the country that issued
# a YSF callsign, the result will be stored in this cache
# file.  Subsequent appearances of that callsign can then
# quickly be recalled from cache, saving 3-5 seconds each
# time that callsign appears.  Unlike the counter-tracking,
# history, and talk-group temp files employed by this
# script, this file will NOT be deleted upon program exit.
# This makes an already populated file immediately available,
# if the script is stopped by the user and then restarted.
# As the file is written to the ram-based "/tmp" filesystem,
# it is, however, volatile, and will be rebuilt from scratch
# with every reboot.
DXCC_CACHE_FILE="/tmp/lastqso-dxcc-cache-${MY_TTY}"
touch "${DXCC_CACHE_FILE}"

#===============
# Finding a way to get the screen width of a window that can
# be dynamically re-sized is funky, in bash.  Neither tput,
# stty, bash's own $LINES and $COLUMNS, or other such tools
# work to read a terminal's screen size, from within a script.
# So, I have to call on a few lines of python.
#
# The advantage to using the "here doc" is that I don't need
# to host, bundle, distribute and install a trivial external
# python script alongside pistar-lastqso.  Everything needed
# stays within the bash script.
#
# Note to self:
# My 40" 1080P screen is...
# 61 lines x 228 columns - HDMI-connected to Pi
# 45 lines x 157 columns - SSH (PuTTY Max Windowed-mode)
# 49 lines x 160 columns - SSH (Putty Full Screen-mode)
# My Windows laptop screen with PuTTY is...
# 44 lines x 168 columns - SSH (PuTTY Max Windowed Mode)
# 48 lines x 170 columns - SSH (Putty Full Screen-mode)
export LINES COLUMNS
PY3_SCRIPT=$(cat <<'EOF'
import os
ts = os.get_terminal_size(2)
ts.lines
ts.columns
print (ts.lines, ts.columns, sep=' ')
EOF
)
# The above is called like this, whenever needed...
read -r LINES COLUMNS <<< "$(python3 -c "${PY3_SCRIPT}")" 2>/dev/null

#===============
# MISC stuff...
# For grepping stuff that includes tabs
GTAB=$'\t'

# Disable line-wrap
# Prevents unexpectedly long fields from busting up the screen.
# (There's one entry in user.csv that is over 170 characters long!)
echo -en "${WRAP_OFF}"

###########################################################
# FUNCTIONS
###########################################################

# For possible future use
#-----------------------------------
fnCENTER()
{
  # Use the python code to get screen size
  # before calling this function.
  LENGTH=${#STRING}
  tput cup $((LINES / 2)) $(((COLUMNS / 2) - (LENGTH / 2)))
  echo "${STRING}"
}

#-----------------------------------
fnGET_MODES()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Primary modes
  DMR_ENABLED="$(grep -A 2 "^\[DMR\]" /etc/mmdvmhost | grep "^Enable")"
  DMR_ENABLED="${DMR_ENABLED#*=}"
  YSF_ENABLED="$(grep -A 2 "^\[System Fusion\]" /etc/mmdvmhost | grep "^Enable")"
  YSF_ENABLED="${YSF_ENABLED#*=}"
  DSTAR_ENABLED="$(grep -A 2 "^\[D-Star\]" /etc/mmdvmhost | grep "^Enable")"
  DSTAR_ENABLED="${DSTAR_ENABLED#*=}"
  NXDN_ENABLED="$(grep -A 2 "^\[NXDN\]" /etc/mmdvmhost | grep "^Enable")"
  NXDN_ENABLED="${NXDN_ENABLED#*=}"
  P25_ENABLED="$(grep -A 2 "^\[P25\]" /etc/mmdvmhost | grep "^Enable")"
  P25_ENABLED="${P25_ENABLED#*=}"
  #POCSAG_ENABLED="$(grep -A 2 "^\[POCSAG\]" /etc/mmdvmhost | grep "^Enable")"
  #POCSAG_ENABLED="${POCSAG_ENABLED#*=}"

  # Cross-modes
  DMR2YSF_ENABLED="$(grep -A 1 "^\[Enabled\]" /etc/dmr2ysf | grep "^Enabled")"
  DMR2YSF_ENABLED="${DMR2YSF_ENABLED#*=}"
  DMR2NXDN_ENABLED="$(grep -A 1 "^\[Enabled\]" /etc/dmr2nxdn | grep "^Enabled")"
  DMR2NXDN_ENABLED="${DMR2NXDN_ENABLED#*=}"
  YSF2DMR_ENABLED="$(grep -A 1 "^\[Enabled\]" /etc/ysf2dmr | grep "^Enabled")"
  YSF2DMR_ENABLED="${YSF2DMR_ENABLED#*=}"
  YSF2NXDN_ENABLED="$(grep -A 1 "^\[Enabled\]" /etc/ysf2nxdn | grep "^Enabled")"
  YSF2NXDN_ENABLED="${YSF2NXDN_ENABLED#*=}"
  YSF2P25_ENABLED="$(grep -A 1 "^\[Enabled\]" /etc/ysf2p25 | grep "^Enabled")"
  YSF2P25_ENABLED="${YSF2P25_ENABLED#*=}"
}

#-----------------------------------
fnCLEANUP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  rm "${STATIC_TG_FILE}" \
  "${DMR_COUNT_FILE}" \
  "${YSF_COUNT_FILE}" \
  "${QSO_COUNT_FILE}" \
  "${KERCHUNK_COUNT_FILE}" \
  "${ERROR_COUNT_FILE}" \
  "${WARNING_COUNT_FILE}" \
  "${HISTORY_FILE}" 2>/dev/null || :
}

#-----------------------------------
fnCLOSE_FDS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Close the debugging and profiling file descriptors
  exec 3>&- 2>/dev/null
  set +x 2>/dev/null
  exec 4>&- 2>/dev/null
}

#-----------------------------------
# Double high, double wide character set
fnLARGE_FONT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo -n "${SGR0}"
  case ${MY_FONT} in
    5)
      echo "${LARGE_TOP}${*}"
      echo "${LARGE_BOT}${*}"
      ;;
    *)
      echo "${*}"
      ;;
  esac
  echo -n "${CLR_ED}"
}

#-----------------------------------
# Because bash can't do simple floating-point comparisons....
fnCOMPARE_FLOAT_LT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Look for this to return "<" if FLOAT1 is less than FLOAT2
  awk -v FLOAT1="${1}" -v FLOAT2="${2}" 'BEGIN {printf "%s " (FLOAT1<FLOAT2?"<":">=") " %s\n", FLOAT1, FLOAT2}'
}

#-----------------------------------
# Because bash can't do simple floating-point comparisons....
fnCOMPARE_FLOAT_GT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Look for this to return ">" if FLOAT1 is greater than FLOAT2
  awk -v FLOAT1="${1}" -v FLOAT2="${2}" 'BEGIN {printf "%s " (FLOAT1>FLOAT2?">":"<=") " %s\n", FLOAT1, FLOAT2}'
}

#-----------------------------------
# Gratuitous eye-candy
# UTF-8 has richer, more predictable box-drawing characters
# than old fashioned terminfo acsc characters.  The caveat is
# that the terminal must support UTF-8.
#
# shellcheck disable=SC2034
fnDEFINE_BOXCHARS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Unicode box-drawing characters.  We'll use a few of these.
  #         0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
  # U+250x  â  â  â  â                          â        â
  # U+251x  â        â  â        â  â        â  â  â
  # U+252x  â         â£  â¤  â¥        â¨        â«  â¬        â¯
  # U+253x  â°        â³  â´        â·  â¸        â»  â¼        â¿
  # U+254x        â                          â
  # U+255x  â  â  â  â  â  â  â  â  â  â  â  â  â  â  â  â
  # U+256x  â   â¡  â¢  â£  â¤  â¥  â¦  â§  â¨  â©  âª  â«  â¬

  # Unicode block elements.
  #         0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
  # U+258x  â           â           â           â
  # U+259x  â  â  â  â

  # HAS_UTF8="$(echo "${LC_ALL}${LC_CTYPE}${LANG}" | grep "UTF-8")"
  if [[ "$(locale charmap)" =~ "UTF-8" ]]
  then
    # UTF-8 single-line box-drawing characters
    SBOX_BR="$(printf "\u2518")"	# â bottom-right corner
    SBOX_TR="$(printf "\u2510")"	# â top-right corner
    SBOX_TL="$(printf "\u250C")"	# â top-left corner
    SBOX_BL="$(printf "\u2514")"	# â bottom-left corner
    SBOX_CC="$(printf "\u253C")"	# â¼ center cross
    SBOX_HL="$(printf "\u2500")"	# â horizontal line
    SBOX_LT="$(printf "\u251C")"	# â left-side "T" (right-pointing)
    SBOX_RT="$(printf "\u2524")"	# â¤ right-side "T" (left-pointing)
    SBOX_BT="$(printf "\u2534")"	# â´ bottom "T" (up-pointing)
    SBOX_TT="$(printf "\u252C")"	# â¬ top "T" (down-pointing)
    SBOX_VL="$(printf "\u2502")"	# â vertical line
    # UTF-8 double-line box-drawing characters
    DBOX_BR="$(printf "\u255D")"	# â bottom-right corner
    DBOX_TR="$(printf "\u2557")"	# â top-right corner
    DBOX_TL="$(printf "\u2554")"	# â top-left corner
    DBOX_BL="$(printf "\u255A")"	# â bottom-left corner
    DBOX_CC="$(printf "\u256C")"	# â¬ center cross
    DBOX_HL="$(printf "\u2550")"	# â horizontal line
    DBOX_LT="$(printf "\u2560")"	# â  left-side "T" (right-pointing)
    DBOX_RT="$(printf "\u2563")"	# â£ right-side "T" (left-pointing)
    DBOX_BT="$(printf "\u2569")"	# â© bottom "T" (up-pointing)
    DBOX_TT="$(printf "\u2566")"	# â¦ top "T" (down-pointing)
    DBOX_VL="$(printf "\u2551")"	# â vertical line
    # UTF-8 mixed outer double/inner single-line box-drawing characters
    DSBOX_LT="$(printf "\u255F")"	# â mixed dbl/sgl-line left-side "T" (right-pointing)
    DSBOX_RT="$(printf "\u2562")"	# â¢ mixed dbl/sgl-line right-side "T" (left-pointing)
    DSBOX_BT="$(printf "\u2567")"	# â§ bottom "T" (up-pointing)
    DSBOX_TT="$(printf "\u2564")"	# â¤ top "T" (down-pointing)
    # UTF-8 mixed outer single/inner double-line box-drawing characters
    SDBOX_LT="$(printf "\u255E")"	# â mixed sgl/dbl-line left-side "T" (right-pointing)
    SDBOX_RT="$(printf "\u2561")"	# â¡ mixed sgl/dbl-line right-side "T" (left-pointing)
    SDBOX_BT="$(printf "\u2568")"	# â¨ bottom "T" (up-pointing)
    SDBOX_TT="$(printf "\u2565")"	# â¥ top "T" (down-pointing)

    HALF_SHADOW="$(printf "\u2580")"	# â half-height shadow
    FULL_SHADOW="$(printf "\u2588")"	# â full-height shadow
  else
    # if no UTF-8, use ascii characters to draw a poor-man's box
    SBOX_BR="+"
    SBOX_TR="+"
    SBOX_TL="+"
    SBOX_BL="+"
    SBOX_CC="+"
    SBOX_HL="-"
    SBOX_LT="+"
    SBOX_RT="+"
    SBOX_BT="+"
    SBOX_TT="+"
    SBOX_VL="|"

    DBOX_BR="+"
    DBOX_TR="+"
    DBOX_TL="+"
    DBOX_BL="+"
    DBOX_CC="+"
    DBOX_HL="="
    DBOX_LT="+"
    DBOX_RT="+"
    DBOX_BT="+"
    DBOX_TT="+"
    DBOX_VL="|"

    DSBOX_LT="+"
    DSBOX_RT="+"
    DSBOX_BT="+"
    DSBOX_TT="+"

    SDBOX_LT="+"
    SDBOX_RT="+"
    SDBOX_BT="+"
    SDBOX_TT="+"

    HALF_SHADOW="#"
    FULL_SHADOW="#"
  fi
  DBL_LINE="$(printf "${DBOX_HL}%.0s" {1..76})"
}

#-----------------------------------
# Usage: fnDRAW_BOX BOX_TOP BOX_LEFT BOX_HEIGHT BOX_WIDTH BOX_STYLE BOX_FILL BOX_SHADOW
#   BOX_TOP and BOX_LEFT = the position of the upper left corner of the box
#   BOX_HEIGHT = the number of rows of the box
#   BOX_WIDTH = the number of columns of the box
#   BOX_STYLE = single [1] or double-line [2] box-drawing characters
#   BOX_FILL = preserve [0] or erase [1] anything within the box
#   BOX_SHADOW = no drop-shadow [0] or add a drop-shadow [1]
fnDRAW_BOX()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  #----------
  BOX_TOP=${1}
  BOX_LEFT=${2}
  BOX_HEIGHT=${3}
  BOX_WIDTH=${4}
  BOX_STYLE=${5}
  BOX_FILL=${6}
  BOX_SHADOW=${7}

  BOX_BOTTOM=$((BOX_TOP + BOX_HEIGHT))
  BOX_RIGHT=$((BOX_LEFT + BOX_WIDTH))

  if [[ "${BOX_STYLE}" = "1" ]]
  then
    # single-line characters
    BOX_TL="${SBOX_TL}"
    BOX_TR="${SBOX_TR}"
    BOX_HL="${SBOX_HL}"
    BOX_VL="${SBOX_VL}"
    BOX_BL="${SBOX_BL}"
    BOX_BR="${SBOX_BR}"
  else
    # double-line characters
    BOX_TL="${DBOX_TL}"
    BOX_TR="${DBOX_TR}"
    BOX_HL="${DBOX_HL}"
    BOX_VL="${DBOX_VL}"
    BOX_BL="${DBOX_BL}"
    BOX_BR="${DBOX_BR}"
  fi

  #----------
  # Top line of the box
  if [[ ${BOX_WIDTH} -gt 2 ]]
  then
    tput cup "${BOX_TOP}" "${BOX_LEFT}"
    for ((I=BOX_LEFT; I<=BOX_RIGHT; I++))
    do
      printf -- "${BOX_HL}%0.s"
    done
  fi

  #----------
  # Top-left corner
  tput cup "${BOX_TOP}" "${BOX_LEFT}"
  echo -n "${BOX_TL}"
  # Top-right corner
  tput cup "${BOX_TOP}" $((BOX_LEFT + BOX_WIDTH))
  echo -n "${BOX_TR}"

  BOX_CURRENT_LINE=$((BOX_TOP + 1))

  #----------
  # preserve or erase what's between the sides of the box
  COUNT=1
  PADDING=""
  if [[ "${BOX_FILL}" = "0" ]]
  then
    PAD="$(tput cuf1)"		# Move cursor one space to the right
  else
    PAD=" "			# one space
  fi
  until [[ ${COUNT} -eq ${BOX_WIDTH} ]]
  do
    PADDING="${PADDING}${PAD}"
    ((COUNT++))
  done

  #----------
  # sides of the box
  until [[ ${BOX_CURRENT_LINE} -eq ${BOX_BOTTOM} ]]
  do
    tput cup "${BOX_CURRENT_LINE}" "${BOX_LEFT}"
    echo -n "${BOX_VL}${PADDING}${BOX_VL}"
    # if shadow, print the block
    if [[ ${BOX_SHADOW} -eq 1 ]]
    then
      echo -n "${FULL_SHADOW}"
    fi
    ((BOX_CURRENT_LINE++))
  done

  #----------
  # Bottom line of the box
  if [[ ${BOX_WIDTH} -gt 2 ]]
  then
    tput cup "${BOX_BOTTOM}" "${BOX_LEFT}"
    for ((I=BOX_LEFT; I<=BOX_RIGHT; I++))
    do
      printf -- "${BOX_HL}%0.s"
    done
  fi

  #----------
  # Bottom-left corner
  tput cup "${BOX_BOTTOM}" "${BOX_LEFT}"
  echo -n "${BOX_BL}"
  # Bottom-right corner
  tput cup "${BOX_BOTTOM}" "${BOX_RIGHT}"
  echo -n "${BOX_BR}"
  # if shadow, print the row of blocks
  if [[ ${BOX_SHADOW} -eq 1 ]]
  then
    tput cup "${BOX_CURRENT_LINE}" "$((BOX_RIGHT + 1))"
    echo -n "${FULL_SHADOW}"
    tput cup $((BOX_BOTTOM + 1)) $((BOX_LEFT + 2))
    for ((I=BOX_LEFT; I<="$((BOX_RIGHT -1))"; I++))
    do
      printf "${HALF_SHADOW}%0.s"
    done
  fi
}

#-----------------------------------
fnDMR_BM_STATIC_TGS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # This retrieves the TGs, and returns them one per line.
  curl -s "https://api.brandmeister.network/v1.0/repeater/?action=profile&q=${HOTSPOT_ID}" \
    | sed -u 's/"talkgroup":/\n/g' | grep "${HOTSPOT_ID}" | cut -f1 -d"," \
    > "${STATIC_TG_FILE}"

  # This takes the multiple lines, and puts them all on one line.
  STATIC_LIST=""
  while FS='' read -r TALKGROUP
  do
    STATIC_LIST="${STATIC_LIST} ${TALKGROUP}"
  done < "${STATIC_TG_FILE}"
  echo "${STATIC_LIST}"
}

#-----------------------------------
fnTOP_DATA()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # This function deals with the optional non-scrolling zone,
  # created when the -t|--top option is specified on the cmdline.

  # This padding is appended to most of the displayed values at top of
  # the "-t" screen, and then truncated to an appropriate length.  This
  # acts to clear out any artifacts of previous screens that are some-
  # times left behind when the user changes the size of an SSH window.
# TOP_PAD=".........................................................."
  TOP_PAD="                                                          "

#KPC
  #----------
  if [[ ${REPLAY} -eq 1 ]]
  then
    WORKING_LOG="${REPLAY_LOG}"
  fi
  MY_LOG="$(basename "${WORKING_LOG}")"
  # Pad, and truncate to fit
  MY_LOG="${MY_LOG}${TOP_PAD}"
  MY_LOG="${MY_LOG:0:23}"

  #----------
  # GATHER LINE 0 DATA...
  # This script's version
  # Pad, and truncate to fit
  MY_VER="${IS_DEV}${VERSION}${IS_DEV}${TOP_PAD}"
  MY_VER="${MY_VER:0:7}"

  # Datestamp of the user.csv file
# CSV_DATE="$(stat /usr/local/etc/user.csv 2>/dev/null | grep "^Modify" | awk '{ print $2 }')"
  CSV_DATE="$(stat --print=%y /usr/local/etc/user.csv 2>/dev/null)"
  IFS=' '; CUT_ARRAY=(${CSV_DATE}); unset IFS;
  CSV_DATE="${CUT_ARRAY[0]}"
  unset CUT_ARRAY
  # Pad, and truncate to fit
  CSV_DATE="${CSV_DATE}${TOP_PAD}"
  CSV_DATE="${CSV_DATE:0:11}"

  # Datestamp of the cty.dat file
  DAT_DATE="$(stat --print=%y /usr/local/etc/cty.dat 2>/dev/null)"
  IFS=' '; CUT_ARRAY=(${CSV_DATE}); unset IFS;
  DAT_DATE="${CUT_ARRAY[0]}"
  unset CUT_ARRAY
  # Pad, and truncate to fit
  DAT_DATE="${DAT_DATE}${TOP_PAD}"
  DAT_DATE="${DAT_DATE:0:11}"

  #----------
  # GATHER LINE 1 DATA...
  # Hotspot TX & RX frequencies
  # <rant> I hate that bash can't do simple floating-point math without external help. </rant>
  TX="$(printf %.4f "$(echo print "$(grep -A 9 "\[Info\]" /etc/mmdvmhost | grep "^TXFrequency=" 2>/dev/null | cut -f2 -d"=" | sed -u 's/Hz//')"/1000000 | perl)")"
  # Pad, and truncate to fit
  TX="${TX}${TOP_PAD}"
  TX="${TX:0:12}"

  RX="$(printf %.4f "$(echo print "$(grep -A 9 "\[Info\]" /etc/mmdvmhost | grep "^RXFrequency=" 2>/dev/null | cut -f2 -d"=" | sed -u 's/Hz//')"/1000000 | perl)")"
  # Pad, and truncate to fit
  RX="${RX}${TOP_PAD}"
  RX="${RX:0:12}"

  # Details about the modem
  DESCRIPTION="$(grep "description:" /var/log/pi-star/MMDVM* | tail -1)"

  # Firmware version
  FW="$(echo "${DESCRIPTION}" | awk '{ print $9 }')"
  # Pad, and truncate to fit
  FW="${FW}${TOP_PAD}"
  FW="${FW:0:24}"

  # Isolate the field that contains "MHz" within the record
  # If we can't find it, set it to "unknown"
  TCXO="$(printf %2.4f "$(echo "${DESCRIPTION}" | awk '/MHz/ {for(i=NF;i>=1;i--) {if($i~/MHz/) {$0=i":"$i}} print}' | cut -f3 -d":" | sed -u 's/MHz//')")"
  TCXO=${TCXO:-'unknown'}
  # Pad, and truncate to fit
  TCXO="${TCXO}${TOP_PAD}"
  TCXO="${TCXO:0:10}"

  #----------
  # GATHER LINE 2 DATA...
  if [[ "${YSF_ENABLED}" = "1" ]]
  then
    YSF_MASTER="$(grep -A 5 "^\[Network\]" /etc/ysfgateway | grep "^Startup")"
    YSF_MASTER="${YSF_MASTER#*=}"
  else
    if systemctl status dmr2ysf | grep -q "active (running)"
    then
      YSF_MASTER="YSF2DMR ($(grep -A 5 "^\[Network\]" /etc/ysfgateway | grep "^Startup"))"
      YSF_MASTER="${YSF_MASTER#*=}"
    else
      YSF_MASTER="Not Enabled"
    fi
  fi
  # Pad, and truncate to fit
  YSF_MASTER="${YSF_MASTER}${TOP_PAD}"
  YSF_MASTER="${YSF_MASTER:0:20}"

  if [[ "${DMR_ENABLED}" = "1" ]]
  then
    DMR_MASTER="$(grep -A 10 "^\[DMR Network\]" /etc/mmdvmhost | grep "^Address")"
    DMR_MASTER="${DMR_MASTER#*=}"

    DMR_MASTER_NAME="$(grep "${GTAB}${DMR_MASTER}${GTAB}" /usr/local/etc/DMR_Hosts.txt | awk '{ print $1 }' | sed -u 's/_/ /g')"
  else
    if systemctl status ysf2dmr | grep -q "active (running)"
    then
      DMR_MASTER="DMR2YSF ($(grep -A 5 "^\[DMR Network 3\]" /etc/dmrgateway | grep "^Name"))"
      DMR_MASTER="${DMR_MASTER#*=}"
    else
      DMR_MASTER="Not Enabled"
    fi
  fi
  # Pad, and truncate to fit
  DMR_MASTER="${DMR_MASTER}${TOP_PAD}"
  DMR_MASTER="${DMR_MASTER:0:32}"

  #----------
  # GATHER LINE 3 DATA...
  # CPU_TEMP is fetched in fnNOSCROLL_ZONE, where it can be updated frequently,
  # rather than here in this function, which is called only once.
  MODEM_PORT="$(grep -A 25 "^\[Modem\]" /etc/mmdvmhost | grep "^Port")"
  IFS='/'; CUT_ARRAY=(${MODEM_PORT}); unset IFS;
  MODEM_PORT="${CUT_ARRAY[2]}"
  unset CUT_ARRAY

  PLATFORM="$(platformDetect.sh)"

  #----------
  # GATHER LINE 4 DATA...
  if grep "${GTAB}${DMR_MASTER}${GTAB}" "${DMRHOSTS}" | grep -q "^BM_"
  then
    STATIC_LIST="$(fnDMR_BM_STATIC_TGS)"

    # See if the total characters is wider than what we can show
    # within the line-length limit of the no-scroll region.
    STATIC_LENGTH=${#STATIC_LIST}
    if [[ ${STATIC_LENGTH} -gt 61 ]]
    then
      # If so, take only the first 61 chars and add an elipsis (...)
      # to show we are aware there's more, but just won't display it.
      #
      # Most would recommend against too many statically linked talk-
      # groups (including the BM admins), and that dynamically linked
      # talkgroups should suffice for most people's needs.
      STATIC_LIST="${STATIC_LIST:0:58}${CYA}${DIM}..."
    fi
    STATIC_LIST="${STATIC_LIST}${TOP_PAD}"
    STATIC_LIST="${STATIC_LIST:0:61}"

    STATIC_COUNT="$(printf %02d "$(grep -c . "${STATIC_TG_FILE}")")"
    STATIC_LINE="${CYA}STATIC TGs(${WHI}${BOLD}${STATIC_COUNT}${SGR0}${CYA}):${SGR0}${WHI}${BOLD}${STATIC_LIST}${SGR0}"
  else
    STATIC_LINE="${CYA}Network is not BrandMeister - No API available to retrieve any Static TGs${SGR0}"
  fi
}

#-----------------------------------
fnDEV_INFO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # If running on a big screen, this prints some info in the
  # top-right corner of the screen, on the non-scrolling lines,
  # when -t|--top is used.
  if [[ ${COLUMNS} -lt 130 ]] || [[ "${SHOW_DEV_INFO}" = "0" ]]
  then
    return
  fi

  # If null, set to "n/a"
  BG_PID=${BG_PID:-'n/a'}

  DEV_STRING[1]="  Options & Parameters: ${MY_CMDLINE}"
  DEV_STRING[2]="  Debugging: 3>${DEBUG_LOG} Profiling: 4>${PROFILING_LOG}"
  DEV_STRING[3]="  ${TERM} Display=${LINES}x${COLUMNS} TTY=${MY_TTY} PID=${MY_PID} BG_PID=${BG_PID}"
  DEV_STRING[4]="  Modes and X-Modes: YSF=${YSF_ENABLED} DMR=${DMR_ENABLED} NXDN=${NXDN_ENABLED} DSTAR=${DSTAR_ENABLED} P25=${P25_ENABLED}"
  DEV_STRING[5]="  YSF2DMR=${YSF2DMR_ENABLED} YSF2NXDN=${YSF2NXDN_ENABLED} YSF2P25=${YSF2P25_ENABLED} DMR2YSR=${DMR2YSF_ENABLED} DMR2NXDN=${DMR2NXDN_ENABLED}"
  DEV_STRING[6]="  Counts: DMR=${DMR_COUNT} YSF=${YSF_COUNT} KERCH=${KERCHUNK_COUNT} ERR=${ERROR_COUNT} WARN=${WARNING_COUNT} RESTART=${LOG_RESTARTS}"

#KPC
  # In replay mode, text is bright yellow.
  # In normal mode, text is pale cyan.
  if [[ ${REPLAY} -eq 1 ]]
  then
    echo -n "${BOLD}${YEL}"
    DEV_STRING[7]="  *** REPLAY MODE *** REPLAY MODE *** REPLAY MODE *** REPLAY MODE ***"
  else
    echo -n "${DIM}${CYA}"
    DEV_STRING[7]="----------------------------------------------------"
  fi

  DEV_INDEX=1
  until [[ ${DEV_INDEX} -gt 7 ]]
  do
    # tput references lines, beginning at 0.  The array begins
    # at 1.  So we subtract 1 from the array index, to get the
    # line number needed for tput.
    X=$(( "${DEV_INDEX}" - 1 ))

    # Subtract the length of the string from the width of the
    # screen, to find the column at which to begin printing.
    Y=$(( ("${COLUMNS}" - ${#DEV_STRING[DEV_INDEX]}) - 1 ))

    # Print each line, flush right, at right edge of screen.
    tput cup "${X}" "${Y}"
    echo -n "${DEV_STRING[DEV_INDEX]}"

    ((DEV_INDEX++))
  done
  echo -n "${SGR0}"
}

#-----------------------------------
fnNOSCROLL_ZONE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "${TOP}" = "0" ]]
  then
    return
  fi

  # Save the current cursor position, and turn the cursor off
  echo -n "${CUR_SC}${CUR_OFF}"

  # Set the whole screen as scrollable
  tput csr 0 $((LINES - 1))
  # Go to line 0
  echo -n "${CUR_HOME}"

  # Define the scrolling region of the screen as the line just
  # below the no-scroll region, to the bottom of screen.
  # (Screen lines are numbered beginning with line 0.)
  tput csr "${BELOW_NOSCROLL}" $((LINES - 1))

  #----------
  # Print line 0
  echo -en "${CYA}LASTQSO:${SGR0} ${VER_CHECK_COLOR}${MY_VER}${SGR0}\r"
  tput cuf 16
  echo -en "${CYA}DAT:${SGR0} ${WHI}${BOLD}${DAT_DATE}${SGR0}\r"
  tput cuf 32
  echo -en "${CYA}CSV:${SGR0} ${WHI}${BOLD}${CSV_DATE}${SGR0}\r"
  tput cuf 48
  echo "${CYA}LOG:${SGR0} ${WHI}${BOLD}${MY_LOG}${SGR0}"

  #----------
  # Print line 1
  echo -en "${CYA}TX:${SGR0} ${WHI}${BOLD}${TX}${SGR0}\r"
  tput cuf 16
  echo -en "${CYA}RX:${SGR0} ${WHI}${BOLD}${RX}${SGR0}\r"
  tput cuf 32
  echo -en "${CYA}TCXO:${SGR0} ${WHI}${BOLD}${TCXO}${SGR0}\r"
  tput cuf 48
  echo "${CYA}FW:${SGR0} ${WHI}${BOLD}${FW}${SGR0}"

  #----------
  # Print line 2
  CPU_TEMP="$(vcgencmd measure_temp)"
  CPU_TEMP="${CPU_TEMP#*=}"
  CPU_TEMP="${CPU_TEMP/\'/Â°}"

  CPU_TEMP_INT="${CPU_TEMP%.*}"

  if [[ "${CPU_TEMP_INT}" -lt 50 ]]
  then
    CPU_TEMP_COLOR="${GRE}"
  fi
  if [[ "${CPU_TEMP_INT}" -ge 50 ]]
  then
    CPU_TEMP_COLOR="${YEL}"
  fi
  if [[ "${CPU_TEMP_INT}" -ge 69 ]]
  then
    CPU_TEMP_COLOR="${RED}"
  fi

  CPU_TEMP="${CPU_TEMP}${TOP_PAD}"
  CPU_TEMP="${CPU_TEMP:0:10}"

  MODEM_PORT="${MODEM_PORT}${TOP_PAD}"
  MODEM_PORT="${MODEM_PORT:0:10}"

  PLATFORM="${PLATFORM}${TOP_PAD}"
  PLATFORM="${PLATFORM:0:34}"

  echo -en "${CYA}Temp:${SGR0} ${CPU_TEMP_COLOR}${BOLD}${CPU_TEMP}${SGR0}\r"
  tput cuf 16
  echo -en "${CYA}Port:${SGR0} ${WHI}${BOLD}${MODEM_PORT}${SGR0}\r"
  tput cuf 32
  echo "${CYA}Platform:${SGR0} ${WHI}${BOLD}${PLATFORM}${SGR0}"

  #----------
  # Print line 3
# ELAPSED=$(eval "echo $(date -ud "@${SECONDS}" +'$((%s/3600/24)) Days %H Hrs %M Mins %S Secs')")
# shellcheck disable=SC2016
  ELAPSED=$(eval "echo $(date -ud "@${SECONDS}" +'$((%s/3600/24)) Days %H Hrs %M Mins')")
  ELAPSED="${ELAPSED}${TOP_PAD}"
  ELAPSED="${ELAPSED:0:23}"
  echo -en "${CYA}Elapsed:${SGR0} ${WHI}${BOLD}${ELAPSED}${SGR0}\r"

  LOAD_AVG="$(uptime | awk '{ print $(NF-2)" "$(NF-1)" "$NF }')"

  tput cuf 32
  LOAD_AVG="${LOAD_AVG}${TOP_PAD}"
  LOAD_AVG="${LOAD_AVG:0:20}"
  echo "${CYA}Load Avg (1,5,15 mins):${SGR0} ${WHI}${BOLD}${LOAD_AVG}${SGR0}"

  #----------
  # Print line 4
  YSF_MASTER="${YSF_MASTER}${TOP_PAD}"
  YSF_MASTER="${YSF_MASTER:0:20}"
  echo -en "${CYA}YSF MASTER:${SGR0} ${WHI}${BOLD}${YSF_MASTER}${SGR0}\r"
  tput cuf 32
  DMR_MASTER_NAME="${DMR_MASTER_NAME}${TOP_PAD}"
  DMR_MASTER_NAME="${DMR_MASTER_NAME:0:32}"
  echo "${CYA}DMR MASTER:${SGR0} ${WHI}${BOLD}${DMR_MASTER_NAME}${SGR0}"

  #----------
  # Print static talkgroups
  echo "${STATIC_LINE}"

  #----------
  if [[ ${HIST_MAX} -gt 0 ]]
  then
    echo "${REV}${CYA}Previous ${SBOX_VL} From       ${SBOX_VL} To         ${SBOX_VL}  Secs ${SBOX_VL}  BER% ${SBOX_VL} Src ${SBOX_VL} Loss% or S-Meter ${SGR0}${WHI}"
  else
    echo "${REV}${CYA}          History not enabled - 0 lines specified on the commandline        ${SGR0}${WHI}"
  fi

  #----------
  # Print the QSO history lines... newest through oldest
  # Save the history to a file, as well, for auto-restarts.
  true > "${HISTORY_FILE}"
  HIST_COUNT=1
  until [[ ${HIST_COUNT} -gt ${HIST_MAX} ]]
  do
    echo "${SGR0}${HISTORY[HIST_COUNT]}${CLR_EL}"
    echo -e "HISTORY[${HIST_COUNT}]=\"${HISTORY[HIST_COUNT]}\"" >> "${HISTORY_FILE}"
    ((HIST_COUNT++))
  done

  #----------
  # Print red line and clear the remainder of the line
  echo "${RED}${DBL_LINE}${WHI}${SGR0}${CLR_EL}"

  #----------
  if [[ "${SHOW_DEV_INFO}" = "1" ]]
  then
    fnDEV_INFO
  fi

  #----------
  # Now return the cursor back to where it was, and turn it back on
  echo -n "${CUR_RC}${CUR_ON}"
}

#-----------------------------------
fnRESET_SCROLLING()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  if [[ "${TOP}" = "0" ]]
  then
    return
  fi

  # Save the current cursor position, and turn the cursor off
  echo -n "${CUR_SC}${CUR_OFF}"

  # Define the entire screen as the scrolling region
  tput csr 0 $((LINES - 1))

  # Now return the cursor back to where it was.
  echo -n "${CUR_RC}${CUR_ON}"
}

#-----------------------------------
fnUSAGE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo "  USAGE:  Valid options and parameters include:

  Short Form:
    [-c] [-d] [-D] [-e] [-f <1-5>] [-h] [-i]
    [-l] [-m] [-n] [-r /full/path/to/file] [-t [integer]] [-v] [-w]

  Long Form:
    [--csv] [--dat] [--DXCC] [--errors] [--font <1-5>] [--help] [--info]
    [--logo] [--mono] [--nobig] [--replay /full/path/to/file] [--top [integer]]
    [--version] [--wrap]
  " >&2
}

#-----------------------------------
fnPARSE_CMDLINE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Loop through all the cmdline arguments.  It works like this...
  #
  # In the loop, current value would be the option we're evaluating.
  # If the option takes a parameter, we "look ahead" at the "next"
  # indexed value, and see if it makes sense to the current option.
  # An example would be the -f|--font option, and it's parameter,
  # for font selection.  Once the option, and it's parameter are
  # evaluated, we increment the index enough to skip over that
  # parameter, then loop to evaluate the next option in the array.
  #
  # If the "current" option does not expect a parmeter, we just
  # evaluate as needed, before looping to the next item in the
  # array of arguments and parameters..
  #
  # I chose this method, because both the external GNU getopt
  # command, and bash's builtin getops, have problems....
  #
  #   GNU's getopt does not handle empty flag arguments well.
  #   Bash's builtin getopts does.
  #     (Think of the "-t|--top" option to this script, which can
  #     be used either with or without specifying a history depth)
  #
  #   Bash's getopts does't parse long option names.
  #   GNU's getopt does.
  #     (Think "--help" vs "-h")
  #
  # The method I use can do both - it handles empty arguments (such as
  # the "-t|-top" option when no optional number of history lines is
  # given), and can easliy accomodate long-form options.  It is also,
  # frankly, easier to understand, and more portable, than either
  # GNU's getopt or bash's getopts.

  for (( INDEX=0; INDEX<ARG_LIST_LENGTH; INDEX++ ))
  do
    OPTION="${ARG_LIST[${INDEX}]}"

    case ${OPTION} in
      -c|--csv)
        GET_CSV_NOW=1
        continue
        ;;

      -d|--dat)
        GET_DAT_NOW=1
        continue
        ;;

      -D|--DXCC)
        USE_DXCC=0
        continue
        ;;

      -e|--errors)
        SHOW_LOG_ERRORS=0
        continue
        ;;

      -f|--font)
        # If this option is given, see if the next value
        # is a number from 1 to 5
        NEXT=$((INDEX + 1))
        PARAM="${ARG_LIST[${NEXT}]}"
        if [[ ${PARAM} == ?(-)+([1-5]) ]]
        then
          # It is, so use it to set the font.
          MY_FONT=${PARAM}
          # Skip over the number we were passed, and look
          # for the next cmdline option.
          ((INDEX++))
        else
          # It is not, so show the usage text, and exit.
          echo -n "${BELL}${FLASH}"
          echo -e "\n  ERROR:  The use of \"-f|--font\" requires an integer 1-5" >&2
          fnUSAGE
          exit 1
        fi
        continue
        ;;

      -h|--help)
        fnGET_HELP
        exit
        ;;

      -i|--info)
        SHOW_DEV_INFO=1
        continue
        ;;

      -l|--logo)
        LOGO=0
        continue
        ;;

      -m|--mono)
        # Forground colors
        #BLA=""
        RED=""
        GRE=""
        YEL=""
        BLU=""
        MAG=""
        CYA=""
        WHI=""
        DEF=""

        # Background colors
        # Reserved for possible future use
        # BG_BLA=""
        # BG_RED=""
        # BG_GRE=""
        # BG_YEL=""
        # BG_BLU=""
        # BG_MAG=""
        # BG_CYA=""
        # BG_WHI=""
        # BG_DEF=""
        continue
        ;;

      -n|--nobig)
        USE_BANNER=0
        continue
        ;;

#KPC
      -r|--replay)
        # If this option is given, see if the next value
        # is a file we can read
        NEXT=$((INDEX + 1))
        PARAM="${ARG_LIST[${NEXT}]}"
        if [[ ! -f "${PARAM}" ]]
        then
          echo "The file specified for replay does not exist." >&2
          echo "Aborting" >&2
          exit
        fi
        if [[ ! -r "${PARAM}" ]]
        then
          echo "The file specified for replay lacks read permission." >&2
          echo "Aborting" >&2
          exit
        fi
        REPLAY=1
        REPLAY_LOG="${PARAM}"
        ((INDEX++))
        continue
        ;;

      -t|--top)
        TOP=1
        # If this option is given, see if the next value
        # is a number from 0 to 99
        NEXT=$((INDEX + 1))
        PARAM="${ARG_LIST[${NEXT}]}"
        if [[ ${PARAM} =~ ^-?[0-9]|[1-2][0-9]+$ ]]
        then
          # It is, so use it to set the history depth.
          # By default, the -t|--top history is 5 lines deep.
          # Can be overridden with optional numeric parameter passed to
          # the "-t|--top" cmdline option.  Passing a zero disables the
          # history, but retains the display of all other -t|--top info.
          HIST_MAX="${PARAM}"
          # Skip over the number we were passed, and look
          # for the next cmdline option.
          ((INDEX++))
        else
          # It is not, so assume a default history of 5.
          HIST_MAX=5
        fi
        # When "-t|--top" is used, with or without a history, this defines
        # the line number on which the scrolling region of the screen
        # (the part showing the QSO details) begins.
        BELOW_NOSCROLL=$((HIST_MAX + 8))
        continue
        ;;

      -v|--version)
        fnVERSION
        exit
        ;;

      -w|--wrap)
        NO_WRAP=1
        continue
        ;;

      *)
        echo -n "${BELL}${FLASH}"
        echo -e "\n  ERROR:  \"${OPTION}\" is not a valid option." >&2
        fnUSAGE
        exit 1
        ;;
    esac
  done
}

#-----------------------------------
fnGET_HELP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  cat <<'EOF' | less -M
PISTAR-LASTQSO - HELP

(Cursor Up/Down keys to scroll, Page Up/Dn to page, Q to quit help.)

  With no options, the script watches for DMR and YSF traffic.
  Log entries are parsed and presented as each log line is read.
  Use Ctrl-C to exit.

  -c|--csv
      Download an updated user.csv from radioid.net now, rather than
      waiting for the presently installed copy to age 7 days before it
      updates automatically.

  -d|--dat
      Download an updated cty.dat from country-files.com, rather than
      waiting for the presently installed copy to age 30 days before it
      updates automatically.

  -D|--DXCC
      When resolving QTH location for callsigns, pistar-lastqso first
      gambles that the callsign might also be either a DMR or NXDN
      user.  In which case, a quick check of the DMR user.csv and/or
      NXDN NXDN.csv files will find their QTH data there.

      If the callsign can't be found in those files, pistar-lastqso
      calls upon dxcc.pl to determine the country that issued the call
      sign.  This can potentially impact pistar-lastqso's ability to
      "keep up" with log entries, as each call to dxcc.pl can take up
      to 4 or 5 seconds to resolve.  When YSF traffic lasts more than
      a few seconds, this is no problem, as the script normally just
      sits there saying "QSO In Progress...".  But when the bulk of
      traffic is "[[kerchunks]]", which pistar-lastqso considers any
      traffic lasting less than 2 seconds, the kerchunks can out-pace
      the ability of dxcc.pl to keep up.  A few kerchunks here and
      there are generally not a problem.  But a large series of them
      in quick succession can cause delays.  Effectively, you will be
      listening to one callsign, but still seeing data on the screen
      for QSOs logged many seconds ago.

      This "-D|--DXCC" cmdline option can be used to disable calls
      to the dxcc.pl script, if such delays become an issue for you.

      This option has no affect on DMR traffic.  DMR and NXDN users
      go through a registration process that results in their QTH data
      being readily available in the user.csv and NXDN.csv files, thus
      calls to the dxcc.pl script are never needed for DMR traffic.

  -e|--errors
      By default, pistar-lastqso will display any error messages found
      in the MMDVM log, as they occur.  It is NOT unusual to see an
      occasional, or sporadic message, such as a queue overflow.  But
      if these or other errors are frequent or persist, you may need
      to get help from the pi-star forums.  In the meantime, you can use
      the "-e" or "--error" option to suppress the onscreen reporting
      of these errors.  The errors will however still be counted for
      the current session, and the count will still be reported on the
      exit screen.  It is your responsibility to investigate any cause.

      Use of this option DOES NOT FIX THE ERRORS coming from pi-star.
      It only stops telling you that they are happening.

      NOTE: The script also displays and tallies any WARNINGS that may
      show up in the log.  Although the -e|--error option will supress
      display of ERRORS, it will NOT supress display of WARNINGS.

  -f|--font <1-5>
      The [-f|--font] option forces use of the selected font, regardless
      of screen-width.

      Valid options are 1, 2, 3, 4, or 5
        1 = "small"
        2 = "standard"
        3 = "big"
        4 = "ansi_shadow"
        5 = "emulator-dependent alternate charset"

      If this option is omitted, the script will auto-select an
      appropriately sized figlet font based on the following screen-
      width thresholds:

        < 80 chars wide:  "small" font
      80-120 chars wide:  "standard" font
        >120 chars wide:  "big" font

      The "ansi_shadow" and "emulator-dependent alternate character set"
      fonts are never auto-selected.

      Font # 5 may not work for everyone.  Not all terminal emulators
      or TERM-types support the ANSI control codes for this feature.

  -h|--help
      Display this help screen, then exit.

  -i|--info
      Shows a little info in the top-right corner of the screen, when
      the following THREE CONDITIONS apply...

      A.) You MUST specify the "-i|--info" option.
      B.) Your display MUST be at least 130 chars wide.
      C.) You MUST also activate the non-scrolling information zone
          at the top of the screen using the "-t|--top" option (the
          number of lines of history, if any, is irrelevant).

      If either B or C above is false, then A is useless.  If all
      three conditions are met, a small block of information, largely
      helpful only to those looking to modify the script, is shown
      in the top-right corner of the screen.  An example looks like
      this:
                       Options & Parameters: -t 10 -f 4 -w -i -l
                   Debugging: 3>/dev/null Profiling: 4>/dev/null
            xterm Display=44x168 TTY=pts0 PID=28578 BG_PID=28887
             Modes and X-Modes: YSF=1 DMR=1 NXDN=0 DSTAR=0 P25=0
             YSF2DMR=0 YSF2NXDN=0 YSF2P25=0 DMR2YSR=0 DMR2NXDN=0
        Counts: DMR=425 YSF=214 KERCH=216 ERR=0 WARN=0 RESTART=0
            ----------------------------------------------------

      The first line shows the options and parameters passed to the
      script when launched.

      The second line lists any targets specified for the debug or
      profiling logs, as described in the ABOUT_DEBUGGING.md and
      ABOUT_PROFILING.md files.

      The third line shows TERM type, and size of the screen in rows &
      columns (useful to those who want to modify the script, as there
      is so much cursor management stuff going on).  Also shown are the
      TTY of the terminal/session the script is running on, the PID of
      the script, and the PID of the background task that watches for
      log activity (daily log rotations and pi-star nightly updates).

      The fourth line shows which of the following modes are enabled
      in pi-star: YSF, DMR, NXDN, DDTAR or P25.  If enabled, the mode
      will show a "1".  Disabled will show a "0".

      The fifth line shows which of the following cross-modes are
      enabled: YSF2DMR, YSF2NXDN, YSF2P25, DMR2YSR, and DMR2NXDN.
      If enabled, the mode will show a "1".  Disabled will show a "0".

      The sixth line shows a number of counters.  The counters repre-
      sent the following: DMR traffic, YSF traffic, Kerchunks, Errors,
      Warnings, and Restarts since program launch.  Regarding the
      restarts, expect typically two such events per day... rotation
      to a new day's log at midnight UTC, and again each night during
      pi-star's nightly update, when services are bounced.  Note too
      that any changes you make to pi-star's config via the GUI will
      also bounce the services, when your changes are saved.

      The last line shows a dashed line in normal operatation mode,
      when watching the live log.  However, when the -r|--replay
      option is specified, a simple reminder appears to indicate
      that the program is running in "replay mode".

  -l|--logo
      Disables the animated logo at startup.

  -m|--mono
      For monochrome displays, this option suppresses all color codes.

  -n|--nobig
      Disable the large font display of callsigns and ID #s.  This
      conserves vertical screen-space.

  -r|--replay /full/path/to/file
      FOR DEVELOPMENT USE: This option allows the specified file to
      be "replayed" from the start, as if it were the current log.
      This aids testing of coding changes, against problematic log
      entries, by replaying those log entries.  Troubleshooting
      another user's log too, becomes possible.  A fully qualified
      filename must be specified.

        Examples:
                -r /full/path/to/file
          --replay /full/path/to/file

        Not:
                -r filename
          --replay filename

      This also allows adding support for modes for which the user
      does not have appropriate radios, by soliciting sample logs
      from contributors who do own radios of the appropriate type.

  -t|--top [integer]
      Adds an information zone to the top of the screen that shows
      the version number of this script, date of the cty.dat and
      user.csv files, name of the active log file, TX and RX freqs,
      the hotspot's TCXO frequency and firmware version, CPU temp,
      the Modem's device node (port), the computer platform/model,
      the DMR and/or YSF Master servers, and the first 5 statically
      defined BrandMeister TalkGroups.

      By default, the use of "-t|--top" also provides a history of
      the last 5 QSOs observed.  However, by specifying an integer
      parameter, the number of QSOs displayed in the history can be
      changed.  A value of 0 (zero) disables the history (but retains
      all the other information in the "-t|--top" section of the
      screen.  Other values determine the number of lines of history
      that will be displayed.

      Examples:
        -t       defaults to 5 lines of history
        -t 0     disables the history
        -t 7     displays a history 7 lines deep
        -t 23    displays a history 23 lines deep

      CAUTION: Specifying too many lines for your actual screen-size
      will yield unpredictable (and certainly unsatisfactory) results.
      I do NOT limit-check this parameter, because SSH sessions in
      dynamically resizable windows could have a different number of
      lines each time the screen is re-sized, rendering useless any
      limit-check performed at startup.

      As a point of reference, "-t 9 --n" will maximize the size of
      the history, while still allowing full details for the QSO in
      progress (without large fonts), on a typical 80x24 display.
      Larger screens will support other combinations.  Feel free to
      experiment - YMMV.

  -v|--version
      Display this script's version number, then exit.

  -w|--wrap
      Ordinarily, if figlet decides it needs to wrap the text that it
      displays, based on the size of the font selected, and the width
      of the screen (in columns), it will do so.  However, setting
      this option tells figlet to ignore the screen width, and just
      keep printing on the same line, even if that means the text will
      disappear off the right edge of the screen.  You sacrifice what-
      ever information was off the edge of the screen, but without
      wasting so much vertical screen space to line-wrap.

                            END OF HELP

(Cursor Up/Down keys to scroll, Page Up/Dn to page, Q to quit help.)

EOF
}

#-----------------------------------
fnVERSION()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  clear
  echo "${BOLD}${WHI}$(basename "${0}") v${VERSION}${SGR0}"
  cat <<'EOF'
Copyright Â© 2022 Ken Cormack, KE8DPF

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.

EOF
}

#-----------------------------------
fnNO_LOGO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  clear
  echo "${BOLD}${WHI}PISTAR-LASTQSO v${VERSION}${SGR0}"
  echo "Copyright Â© 2022 Ken Cormack - KE8DPF"
  echo "${DIM}https://github.com/kencormack/pistar-lastqso${SGR0}"
  echo
}

#-----------------------------------
fnLOGO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  clear
  # Initialize screen, disable line-wrap, cursor off, color to white
  echo -n "${CUR_OFF}${SGR0}${WHI}"

  #----------
  # This "pushes the logo down" from the top of the screen...
  echo -n "${CUR_HOME}"

  for LINE in {6..1}
  do
    echo -n "${DIM}${CYA}"
    {
      cat <<'EOF'
         âââ      ââââââ âââââââââââââââââ  âââââââ ââââââââ âââââââ
         âââ     âââââââââââââââââââââââââ ââââââââââââââââââââââââââ
         âââ     ââââââââââââââââ   âââ    âââ   ââââââââââââââ   âââ
         âââ     ââââââââââââââââ   âââ    âââââ ââââââââââââââ   âââ
         âââââââââââ  âââââââââââ   âââ    ââââââââââââââââââââââââââ
         âââââââââââ  âââââââââââ   âââ     âââââââ ââââââââ âââââââ
EOF
    } | head -"${LINE}" | tail -1
    echo -n "${CUR_HOME}"
    echo -n "${INS_LINE}"
  done

  for I in 1 2
  do
    echo -n "${CUR_HOME}"
    echo -n "${INS_LINE}"
  done

  #----------
  # This increases in "brightness", from dim, to normal, to bold.
  for BRIGHTNESS in "${DIM}" "${SGR0}" "${BOLD}"
  do
    tput cup 3 0
    echo -n "${BRIGHTNESS}${WHI}"
    cat <<'EOF'
         âââ      ââââââ âââââââââââââââââ  âââââââ ââââââââ âââââââ
         âââ     âââââââââââââââââââââââââ ââââââââââââââââââââââââââ
         âââ     ââââââââââââââââ   âââ    âââ   ââââââââââââââ   âââ
         âââ     ââââââââââââââââ   âââ    âââââ ââââââââââââââ   âââ
         âââââââââââ  âââââââââââ   âââ    ââââââââââââââââââââââââââ
         âââââââââââ  âââââââââââ   âââ     âââââââ ââââââââ âââââââ
EOF
  done

  #----------
  tput cup 9 29
  echo -n "${SGR0}${BOLD}${WHI}FOR PI-STAR HOTSPOTS${SGR0}"

  #----------
  # Usage: fnDRAW_BOX BOX_TOP BOX_LEFT BOX_HEIGHT BOX_WIDTH BOX_STYLE BOX_FILL BOX_SHADOW
  # outer yellow box
  echo -n "${SGR0}${YEL}"
  fnDRAW_BOX 1 4 18 69 2 0 0
  # outer red box
  echo -n "${SGR0}${RED}"
  fnDRAW_BOX 0 2 20 73 2 0 0

  #----------
  # lower blue title/copyright box
  echo -n "${SGR0}${BLU}"
  fnDRAW_BOX 14 9 4 59 1 0 0

  #----------
  # title/copyright
  tput cup 15 30
  echo "${SGR0}${BOLD}${YEL}PISTAR-LASTQSO v${VERSION}${WHI}${SGR0}"
  tput cuf 22
  echo "${SGR0}${BOLD}${BLU}Copyright Â© 2022 Ken Cormack - KE8DPF${WHI}${SGR0}"
  tput cuf 17
  echo "${SGR0}${BOLD}${BLU}https://github.com/kencormack/pistar-lastqso${WHI}${SGR0}"
  echo -n "${SGR0}${WHI}${CUR_ON}"

  #----------
  # The 5 mode names, left to right
  echo -n "${SGR0}${BOLD}${WHI}"
  tput cup 11 11
  echo -n "DMR"
  tput cup 11 24
  echo -n "NXDN"
  tput cup 11 37
  echo -n "P25"
  tput cup 11 49
  echo -n "DSTAR"
  tput cup 11 63
  echo -n "YSF"

  #----------
  # The 5 mode boxes, right to left
  # Only DMR and YSF are currently supported,
  # so the others get covered up for now.
  echo -n "${SGR0}${BLU}"
  fnDRAW_BOX 10 61 2 6 1 0 1
  fnDRAW_BOX 10 47 2 8 1 1 1
  fnDRAW_BOX 10 35 2 6 1 1 1
  fnDRAW_BOX 10 22 2 7 1 1 1
  fnDRAW_BOX 10 9 2 6 1 0 1
}

#-----------------------------------
fnCHECK_MODES_ENABLED()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

# if [[ ${DMR_ENABLED} -eq 0 ]] && [[ ${YSF_ENABLED} -eq 0 ]] && [[ ${NXDN_ENABLED} -eq 0 ]] && [[ ${DSTAR_ENABLED} -eq 0 ]]  && [[ ${P25_ENABLED} -eq 0 ]]
  if [[ ${DMR_ENABLED} -eq 0 ]] && [[ ${YSF_ENABLED} -eq 0 ]]
  then
    echo -n "${SGR0}${RED}"
    tput cup 11 18
    for ((I=18; I<=59; I++))
    do
      printf "${DBOX_HL}%0.s"
    done
    fnDRAW_BOX 8 16 6 45 2 1 1

    tput cup 10 24
    echo "${SGR0}${SMUL}${BOLD}${YEL}NEITHER DMR NOR YSF IS ENABLED${SGR0}${WHI}"
    tput cuf 27
    echo "AT LEAST ONE IS REQUIRED"
    tput cuf 20
    echo "PLEASE ENABLE, THEN RE-RUN THIS SCRIPT"
    tput cup 22 0
    echo "${CLR_EL}${CUR_ON}Aborting" >&2

    fnCLOSE_FDS
    # If debugging and/or profiling was used, show the names of the logs, at exit
    if [[ "${DEBUG_LOG}" != "/dev/null" ]] || [[ "${PROFILING_LOG}" != "/dev/null" ]]
    then
      if [[ "${MY_FONT}" = "5" ]]
      then
        DEBUG_PROFILING_LINE=$((LINES - 6))
      else
        DEBUG_PROFILING_LINE=$((LINES - 4))
      fi
      tput cup "${DEBUG_PROFILING_LINE}" 0
      fnLARGE_FONT "DEBUGGING: ${DEBUG_LOG}"
      fnLARGE_FONT "PROFILING: ${PROFILING_LOG}"
      echo
    fi

    tput cup "${LINES}" 0
    echo -e "${TERM_RESET}"
    exit
  fi
}

#-----------------------------------
fnGOODBYE_BOX()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  echo -n "${SGR0}${BLU}"
  fnDRAW_BOX 4 15 11 47 2 1 1

  tput cup 6 19
  echo "${BOLD}${WHI}THANK YOU FOR USING PISTAR-LASTQSO v${VERSION}${SGR0}${DEF}"

  tput cup 8 20
  # shellcheck disable=SC2016
  ELAPSED=$(eval "echo $(date -ud "@${SECONDS}" +'$((%s/3600/24)) Days %H Hrs %M Mins %S Secs')")
  echo -n "${DIM}${CYA}Elapsed: ${ELAPSED}"

  tput cup 9 31
  echo -n "${DIM}${CYA}Log Restarts: "
  printf %02d "${LOG_RESTARTS}"

  QSO_COUNT=$(< "${QSO_COUNT_FILE}")
  tput cup 11 23
  echo -n "${DIM}${WHI}QSOs Observed This Session: ${SGR0}${YEL}"
  printf %05d "${QSO_COUNT}"

  DMR_COUNT=$(< "${DMR_COUNT_FILE}")
  tput cup 12 28
  echo -n "${DIM}${WHI}(DMR ${SGR0}${CYA}"
  printf %05d "${DMR_COUNT}"
  tput cup 12 38
  echo -n "${DIM}${WHI})${SGR0}"

  YSF_COUNT=$(< "${YSF_COUNT_FILE}")
  tput cup 12 40
  echo -n "${DIM}${WHI}(YSF ${SGR0}${CYA}"
  printf %05d "${YSF_COUNT}"
  tput cup 12 50
  echo -n "${DIM}${WHI})${SGR0}"

  KERCHUNK_COUNT=$(< "${KERCHUNK_COUNT_FILE}")
  tput cup 13 23
  if [[ ${QSO_COUNT} -gt 0 ]]
  then
    if [[ ${KERCHUNK_COUNT} -gt ${QSO_COUNT} ]]
    then
      KERCHUNK_COUNT="${QSO_COUNT}"
    fi
    PERCENTAGE="$(awk -v KERCHUNK_COUNT="${KERCHUNK_COUNT}" -v QSO_COUNT="${QSO_COUNT}" 'BEGIN {print (KERCHUNK_COUNT / QSO_COUNT * 100)}')"
  fi
  echo -n "${DIM}${WHI}Includes ${SGR0}${YEL}$(printf %05d "${KERCHUNK_COUNT}")${DIM}${WHI} Kerchunks (${SGR0}${YEL}$(printf %.2f "${PERCENTAGE}")%${DIM}${WHI})${SGR0}"

  if [[ -f "${ERROR_COUNT_FILE}" ]] || [[ -f "${WARNING_COUNT_FILE}" ]]
  then
    ERROR_COUNT=$(< "${ERROR_COUNT_FILE}")
    WARNING_COUNT=$(< "${WARNING_COUNT_FILE}")

    ERROR_COUNT_COLOR=""
    WARNING_COUNT_COLOR=""
    if [[ ${ERROR_COUNT} -gt 0 ]]
    then
      ERROR_COUNT_COLOR="${SGR0}${YEL}"
    fi
    if [[ ${WARNING_COUNT} -gt 0 ]]
    then
      WARNING_COUNT_COLOR="${SGR0}${RED}"
    fi

    if [[ ${ERROR_COUNT} -gt 0 ]] || [[ ${WARNING_COUNT} -gt 0 ]]
    then
      echo -n "${SGR0}${RED}"
      # Usage: fnDRAW_BOX BOX_TOP BOX_LEFT BOX_HEIGHT BOX_WIDTH BOX_STYLE BOX_FILL BOX_SHADOW
      fnDRAW_BOX 14 24 3 30 2 1 1
      tput cup 15 27
      echo -n "${SGR0}${DIM}${WHI}${ERROR_COUNT_COLOR}MMDVM Log ERR MSGS: $(printf %05d "${ERROR_COUNT}")${SGR0}"
      tput cup 16 27
      echo -n "${SGR0}${DIM}${WHI}${WARNING_COUNT_COLOR}MMDVM Log WARNINGS: $(printf %05d "${WARNING_COUNT}")${SGR0}"
    fi
  fi
}

#-----------------------------------
# Watches the logfile for rotation, and appends "MMDVMHOST-STOP"
# to the working log (for the "while read" loop to catch.)
fnMMDVMLOG_FUSER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # This function (exported and spawned later in the script) runs
  # as a background task, in a seperate process.

  # See if the MMDVMHost process has let go of the working log.
  # If so, re-start log monitoring by writing "MMDVMHOST-STOP" to
  # the log we've been watching.  The main "while read" loop
  # will then spot this and re-start monitoring, with the new log.
  # If MMDVMHost still has the log open, do nothing, sleep a few
  # seconds, then check again.
  while true
  do
    # If the parent script goes away, exit this background task
    if [[ "$(pgrep -f "/bin/bash /usr/local/bin/pistar-lastqso")" = "" ]]
    then
      exit
    fi

    # If MMDVMHost has let go of the log, add a marker for the main script's
    # "while read" loop to detect.
    if [[ ! "$(sudo fuser -v "${WORKING_LOG}" 2>&1)" =~ "MMDVMHost" ]]
    then
      echo -e "MMDVMHOST-STOP\n" | sudo tee -a "${WORKING_LOG}"
      sync;sync;sync
      exit
    fi

    # If pistar-lastqso is still running, and MMDVMHost still
    # has the log open, sleep before checking again.
    sleep 2
  done
}

#-----------------------------------
fnSEPARATOR()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  echo -e "\r${CLR_EL}${DBL_LINE}${WHI}${SGR0}"
}

#-----------------------------------
fnLISTENING()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  fnNOSCROLL_ZONE
  echo -en "\r${CLR_EL}"
  echo -n "  ${GRE}${BOLD}Listening for Traffic... ${SGR0}${WHI}${CLR_EL}${CLR_ED}"
  TA_DISPLAYED=0
}

#-----------------------------------
fnQSO_IN_PROGRESS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  fnNOSCROLL_ZONE
  echo -en "\r${CLR_EL}"
  echo -n "  ${YEL}${BOLD}QSO In Progress... ${SGR0}${WHI}${CLR_EL}${CLR_ED}"
  TA_DISPLAYED=0
}

#-----------------------------------
# This takes the DMR user's callsign and looks up the
# city, state, and country fields
fnDMR_CSV_SEARCH()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # Fields in the file:
  # RADIO_ID,CALLSIGN,FIRST_NAME,LAST_NAME,CITY,STATE,COUNTRY
  # We want the last three.
  CSV_RECORD="$(grep ",${CSV_CALLSIGN}," "${USERCSV}" | cut -f5-7 -d"," | sort -u)"

  # I've seen someone using the Malaysian Country Code of 5020386 as their
  # DMR ID, so the log contained only that number (not a callsign), thus
  # the name lookup based on the callsign failed, displaying the "From:" as
  # simply "5020386 ()".  This also resulted in City/State/Country lookup
  # returning "n/a, Ontario, Canada" which was wierd.  Anyway, this makes
  # sure that the absence of a callsign doesn't return bad location data,
  # by making a second pass through the user.csv file, this time looking
  # for the DMR ID number, rather than the callsign.
  if [[ "${CSV_RECORD}" = "" ]]
  then
    CSV_RECORD="$(grep "^${CSV_CALLSIGN}," "${USERCSV}" | cut -f5-7 -d"," | sort -u)"
  fi

  if [[ "${CSV_RECORD}" != "" ]]
  then
    IFS=','; CUT_ARRAY=(${CSV_RECORD}); unset IFS;
    CITY="${CUT_ARRAY[0]}"
    STATE="${CUT_ARRAY[1]}"
    COUNTRY="${CUT_ARRAY[2]}"
    unset CUT_ARRAY
  else
    CITY=""
    STATE=""
    COUNTRY=""
  fi
  # If any fields came back empty, set a default of "n/a" (not available)
  CITY=${CITY:-'n/a'}
  STATE=${STATE:-'n/a'}
  COUNTRY=${COUNTRY:-'n/a'}
}

#-----------------------------------
# This takes the NXDN user's callsign and looks up the
# city, state, and country fields
fnNXDN_CSV_SEARCH()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # Fields in the file:
  # RADIO_ID,CALLSIGN,FIRST_NAME,LAST_NAME,CITY,STATE,COUNTRY
  # We want the last three.
  CSV_RECORD="$(grep ",${CSV_CALLSIGN}," "${NXDNCSV}" | cut -f5-7 -d"," | sort -u)"

  if [[ "${CSV_RECORD}" != "" ]]
  then
    IFS=','; CUT_ARRAY=(${CSV_RECORD}); unset IFS;
    CITY="${CUT_ARRAY[0]}"
    STATE="${CUT_ARRAY[1]}"
    COUNTRY="${CUT_ARRAY[2]}"
    unset CUT_ARRAY
  else
    CITY=""
    STATE=""
    COUNTRY=""
  fi
  # If any fields came back empty, set a default of "n/a" (not available)
  CITY=${CITY:-'n/a'}
  STATE=${STATE:-'n/a'}
  COUNTRY=${COUNTRY:-'n/a'}
}

#-----------------------------------
fnCONVERT_DATE_TIME()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # Convert the log entry UTC date/timestamps to localized, human-readable form
  DATE="$(date -d "${LOGREC_DATE} ${LOGREC_TIME} UTC" +"%a %d %b %Y")"
  TIME="$(date -d "${LOGREC_DATE} ${LOGREC_TIME} UTC" +"%I:%M:%S %p %Z")"
}

#-----------------------------------
fnDMR_PAD_ABSENT_TG()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # "private" call log entries lack "TG" in the log line, which skews
  # the data returned when awk parses positional fields.  These few
  # lines will inject a bogus "PC" (private contact) place-holder to
  # substitute for the missing "TG", so as not to skew positional fields
  # used by awk.  A hack, for sure, but a useful one.
  if [[ "${RECORD}" =~ "voice header" ]] || [[ "${RECORD}" =~ "data header" ]] || [[ "${RECORD}" =~ "end of voice" ]]
  then
    IS_TG="$(echo "${RECORD}" | grep " TG ")"
    if [[ "${IS_TG}" = "" ]]
    then
      RECORD="${RECORD// to / to PC }"
    fi
  fi
}

#-----------------------------------
fnDMR_GET_FROM()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  FROM="$(echo "${RECORD}" | awk '{ print $12 }')"

  # The MMDVMHost daemon internally knows the actual DMR ID# of the user,
  # and does ID number to Callsign lookups from DMRIds.dat.  However, in
  # the logfile, you end up with the Callsign, and lose the ID number.
  # Disabling this lookup gains you the ID numbers in the logfile, but
  # loses the Callsigns.  If I were to disable said lookups via this script,
  # pi-star web-based Dashboard users wouldn't appreciate that.  So, I work
  # backwords, taking the Callsign that MMDVMHost writes to the logs,
  # and looking up the Callsign in the DMRIds.dat file, to find the ID.

  # The problem is that in the early days of DMR, some users were registering
  # multiple IDs (one for their radio, one for each hotspot, etc.)  That
  # practice has been halted, with the prefered method of identifying
  # hotspots by adding a two-digit suffix to the user's normal 7-digit ID.
  # However, those earlier cases of multiple ID numbers mapped to the same
  # Callsign still exist in the file.  Each DMR ID links to only one Callsign,
  # but not every Callsign links to just one ID.  Some Callsigns "hit" more
  # than once in the file.  With no guarantee that I'm picking the correct ID
  # linked to a given Callsign, I just pick the first number, on the
  # assumption that that's the one that represents the user, not one of their
  # hotspot.  I wish MMDVMHost would log both Callsign and ID#.  But it's one
  # or the other, not both.  For the vast majority of cases, my "lesser of
  # two evils" approach will serve well enough.
  #
  # See if the sender is a callsign...
  read -r FROM_ID FROM_NAME <<< "$(grep "${GTAB}${FROM}${GTAB}" "${DMRIDS}" | awk '{ print $1 " " $NF }' | head -1)"
  if [[ "${FROM_NAME}" = "" ]]
  then
    # If not, then see if it is a talkgroup
    FROM_NAME="$(grep "^${FROM};" "${TGLIST}")"
    IFS=';'; CUT_ARRAY=(${FROM_NAME}); unset IFS;
    FROM_NAME="${CUT_ARRAY[2]}"
    unset CUT_ARRAY

    # If that came back empty, see if it's in MY_LIST.txt
    if [[ "${FROM_NAME}" = "" ]] && [[ -f "${MY_LIST}" ]]
    then
      FROM_NAME="$(grep "^${FROM};" "${MY_LIST}")"
      IFS=';'; CUT_ARRAY=(${FROM_NAME}); unset IFS;
      FROM_NAME="${CUT_ARRAY[2]}"
      unset CUT_ARRAY
    fi
  else
    if [[ -f "${USERCSV}" ]]
    then
      # If the recipient is a callsign, not a talkgroup, lookup
      # further info about that callsign in the user.csv file
      CSV_CALLSIGN="${FROM}"
      fnDMR_CSV_SEARCH
    fi
  fi
}

#-----------------------------------
fnDMR_GET_TO()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  TO="$(echo "${RECORD}" | awk '{ print $15 }')"
  TO="${TO%,*}"

  # See if the recipient is a callsign
  read -r TO_ID TO_NAME <<< "$(grep "${GTAB}${TO}${GTAB}" "${DMRIDS}" | awk '{ print $1 " " $NF }' | head -1)"
  # If not, see if it is a talkgroup
  if [[ "${TO_NAME}" = "" ]]
  then
    TO_NAME="$(grep "^${TO};" "${TGLIST}")"
    IFS=';'; CUT_ARRAY=(${TO_NAME}); unset IFS;
    TO_NAME="${CUT_ARRAY[2]}"
    unset CUT_ARRAY

    # Some talkgroups do not have names given, in the TGList_BM.txt
    # file that pi-star updates automatically.  These next few lines
    # allow the user to create a second lookup file in which they
    # can list talkgroups they use, that are not named in pi-star's
    # TGList_BM.txt file.
    #
    # This suplemental file is /usr/local/etc/MY_LIST.txt, and entries
    # in that file must be in the same format as the TGList_BM.txt file.
    # DO NOT INCLUDE SPACES.  Since pi-star will not overwrite your
    # MY_LIST.txt file, the info you list there will survive pi-star's
    # automated updates.
    #
    # Exactly as with the TGList_BM.txt file, the fields in MY_LIST.txt
    # include:

    #   Dest ID;Option;Name;Description
    #   Option: TG:0, REF:1, PC:2

    # Examples:
    #   2627;0;BADEN-WUERTTEMBERG;TG2627
    #   2629;0;SACHSEN/THUERINGEN;TG2629
    #   26232;0;DREILAENDERECK-MITTE-DEUTSCHLAND;TG26232
    #   26274;0;BW-BOEBLINGEN;TG26274
    #   26283;0;REGION-MUENCHEN;TG26283
    #   26287;0;ALLGAEU-BODENSEE;TG26287
    #   26298;0;THUERINGEN;TG26298
    #
    # You can also add certain 'private' IDs here that
    # may not be listed.  Example:
    #   262993;0;GPS-WX;PC262993
    #   310999;0;APRS;PC310999
    #   9999995;0;PISTAR-HOSTFILES;PC9999995
    #   9999996;0;PISTAR-SHUTDOWN;PC9999996
    #   9999997;0;PISTAR-REBOOT;PC9999997
    #   9999998;0;PISTAR-SVC-RESTART;PC9999998
    #   9999999;0;PISTAR-SVC-KILL;PC9999999
    #
    if [[ "${TO_NAME}" = "" ]] && [[ -f "${MY_LIST}" ]]
    then
      TO_NAME="$(grep "^${TO};" "${MY_LIST}")"
      IFS=';'; CUT_ARRAY=(${TO_NAME}); unset IFS;
      TO_NAME="${CUT_ARRAY[2]}"
      unset CUT_ARRAY
    fi
  else
    # If the recipient is a callsign, not a talkgroup, lookup
    # further info about that callsign in the user.csv file
    if [[ -f "${USERCSV}" ]]
    then
      CSV_CALLSIGN="${TO}"
      fnDMR_CSV_SEARCH
    fi
  fi
}

#-----------------------------------
fnBANNER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # If -n|--nobig was used, get out of here.
  if [[ "${USE_BANNER}" = "0" ]]
  then
    return
  fi

  OUTPUT_WIDTH="${COLUMNS}"

  #----------
  if [[ "${LOGREC_MODE}" = "YSF" ]]
  then
    BANNER_COLOR="${YEL}"
  else
    BANNER_COLOR="${WHI}"
  fi

  #----------
  # This deals with the alternate charset font only...
  if [[ "${MY_FONT}" = "5" ]]
  then
    # Font #5 is not a figlet font.  Do what we need to
    # do, and get out.
    fnLARGE_FONT "${BOLD}${BANNER_COLOR}${FROM} ... ${TO}"
    return
  fi

  #----------
  # And this deals with figlet fonts...
  # Disable the large font display callsign to save screen space,
  # by passing the "--nobig" parameter to this script:
  #     pistar-lastqso -n|--nobig
  case ${MY_FONT} in
    1)
      FONT="small"
      ;;
    2)
      FONT="standard"
      ;;
    3)
      FONT="big"
      ;;
    4)
      FONT="ansi_shadow"
      ;;
    *)
      # A screen width of less than 80 columns will select figlet's
      # "small" font.  A screen width greater than 80 columns will
      # use figlet's larger "standard" font.  A screen width greater
      # than 120 columns will use figlet's "big" font.
      FONT="small"
      if [[ "${COLUMNS}" -gt 80 ]]
      then
        FONT="standard"
      fi
      if [[ "${COLUMNS}" -gt 120 ]]
      then
        FONT="big"
      fi
      ;;
  esac

  #----------
  # This flag is set with the "-w|--wrap" cmdline option.
  if [[ "${NO_WRAP}" = "1" ]]
  then
    OUTPUT_WIDTH=1000
  fi

  #----------
  BANNER="$(figlet -w "${OUTPUT_WIDTH}" -f "${FONT}" "${FROM} ... ${TO}")"
  echo "${BOLD}${BANNER_COLOR}${BANNER}${SGR0}"

  #----------
  # Tighten up the leading with these two fonts.
  # This moves the cursor up one line to recover
  # an extra blank line that follows these fonts.
  case ${FONT} in
    "big"|"ansi_shadow")
      echo -n "${CUR_UP}"
      ;;
    *)
      ;;
  esac
  echo -n "${CLR_ED}"
}

#-----------------------------------
fnDMR_GET_VOICE_OR_DATA()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # Determine if voice or data
  TYPE="$(echo "${RECORD}" | awk '{ print $9 }')"
  if [[ "${TYPE}" = "data" ]]
  then
    BLOCKS="$(echo "${RECORD}" | awk '{ print $16 }')"
    TYPE="${YEL}Data Transfer"
  else
    TYPE="${CYA}Voice Call"
  fi
}

#-----------------------------------
fnYSF_END_NETWORK_TRAFFIC()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # Fields to pass to the history...
  SECS="${LOGREC_SECS}"
  IFS='%'; CUT_ARRAY=(${LOGREC_BER}); unset IFS;
  BER="${CUT_ARRAY[0]}"
  unset CUT_ARRAY

  IFS='%'; CUT_ARRAY=(${LOGREC_LOSS}); unset IFS;
  LOSS="${CUT_ARRAY[0]}"
  unset CUT_ARRAY

  fnCOLORIZE_BER
  fnCOLORIZE_LOSS

  echo -en "\r${CLR_EL}"
  echo -en "\r${DIM}Dur.:${SGR0} ${BLU}${BOLD}${LOGREC_SECS}${SGR0}${WHI}${DIM}sec\r"
  tput cuf 18
  echo -en "${DIM}BER:${SGR0} ${BER_COLOR}${BOLD}${BER}%${SGR0}${WHI}\r"
  tput cuf 32
  echo -en "${DIM}Loss:${SGR0} ${LOSS_COLOR}${BOLD}${LOSS}%${SGR0}${WHI}\r"

  if [[ -n "$(echo "${SECS}" | awk '$1 <2.0{print}')" ]]
  then
    ((KERCHUNK_COUNT++))
    echo "${KERCHUNK_COUNT}" > "${KERCHUNK_COUNT_FILE}"
    tput cuf 64
    echo "${YEL}[[kerchunk]]${SGR0}${WHI}"
  else
    echo
  fi

  fnBUILD_HISTORY
  echo -n "${MAG}"
  fnSEPARATOR
  fnLISTENING
}

#-----------------------------------
fnYSF_SHOW_CURRENT_CALL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  #----------
  # Show our human-readable date/time
  echo -n "${DIM}Date:${SGR0} ${BLU}${BOLD}${DATE}${SGR0}${WHI}"
  tput cuf 11
  echo -n "${DIM}Time:${SGR0} ${BLU}${BOLD}${TIME}${SGR0}${WHI}"
  tput cuf 4
  echo -n "${DIM}QSOs Watched:${SGR0} ${BLU}${BOLD}"
  printf %05d "${QSO_COUNT}"
  echo "${SGR0}${WHI}${CLR_ED}"

  IFS='/'; CUT_ARRAY=(${FROM}); unset IFS;
  CSV_FROM="${CUT_ARRAY[0]}"
  unset CUT_ARRAY
  IFS='-'; CUT_ARRAY=(${CSV_FROM}); unset IFS;
  CSV_FROM="${CUT_ARRAY[0]}"
  unset CUT_ARRAY

  FROM_NAME="$(grep ",${CSV_FROM}," "${USERCSV}" "${NXDNCSV}" | tail -1)"
  IFS=','; CUT_ARRAY=(${FROM_NAME}); unset IFS;
  FROM_NAME="${CUT_ARRAY[2]}"
  unset CUT_ARRAY

  #----------
  if [[ -n "${FROM_NAME}" ]]
  then
    P_FROM_NAME="$(printf "%-15s" "(${FROM_NAME})")"
    echo -en "${DIM}From:${SGR0} ${BOLD}${FROM} ${P_FROM_NAME}${SGR0}\r"
  else
    echo -en "${DIM}From:${SGR0} ${BOLD}${FROM}${SGR0}\r"
  fi
  ((YSF_COUNT++))
  echo "${YSF_COUNT}" > "${YSF_COUNT_FILE}"

  #----------
  tput cuf 31
  if [[ -n "${LOGREC_MASTER}" ]]
  then
    echo "${DIM} To..:${SGR0} ${BOLD}${LOGREC_DG_ID} ${LOGREC_DG_ID_NUM} ${DIM}at${SGR0} ${BOLD}${LOGREC_MASTER}${SGR0}${WHI}${CLR_ED}"
  else
    echo "${DIM} To..:${SGR0} ${BOLD}${LOGREC_DG_ID} ${LOGREC_DG_ID_NUM}${SGR0}${WHI}${CLR_ED}"
  fi

  #----------
  echo -en "${DIM}Mode:${SGR0} ${BOLD}${CYA}YSF${SGR0}${WHI}\r"
  tput cuf 32
  echo "${DIM}Src.:${SGR0} ${BOLD}${CYA}${SOURCE}${SGR0}${WHI}${CLR_ED}"

  #----------
  CSV_CALLSIGN="${FROM}"
  IFS='/'; CUT_ARRAY=(${CSV_CALLSIGN}); unset IFS;
  CSV_CALLSIGN="${CUT_ARRAY[0]}"
  unset CUT_ARRAY
  IFS='-'; CUT_ARRAY=(${CSV_CALLSIGN}); unset IFS;
  CSV_CALLSIGN="${CUT_ARRAY[0]}"
  unset CUT_ARRAY

  #----------
  # Maybe the callsign is also a DMR user...
  QTH_SRC="user.csv"
  CSV_RECORD="$(grep ",${CSV_CALLSIGN}," "${USERCSV}" | cut -f5-7 -d"," | sort -u)"
  if [[ "${CSV_RECORD}" = "" ]]
  then
    # Maybe the callsign is also a NXDN user...
    QTH_SRC="NXDN.csv"
    CSV_RECORD="$(grep ",${CSV_CALLSIGN}," "${NXDNCSV}" | cut -f5-7 -d"," | sort -u)"
  fi
  if [[ "${CSV_RECORD}" != "" ]]
  then
    # Callsign was found in one or the other csv file
    IFS=','; CUT_ARRAY=(${CSV_RECORD}); unset IFS;
    CITY="${CUT_ARRAY[0]}"
    STATE="${CUT_ARRAY[1]}"
    COUNTRY="${CUT_ARRAY[2]}"
    unset CUT_ARRAY
  else
    # Callsign was not found in either csv file
    CITY=""
    STATE=""
    COUNTRY=""

    # Last resort: Look up country based on callsign prefix
    if [[ "${USE_DXCC}" = "1" ]]
    then
      if echo "${FROM}" | cut -f1 -d"-" | cut -c1-4 | grep -q "[0-9]"
      then
        QTH_SRC="cty.dat"
        IFS='/'; CUT_ARRAY=(${LOGREC_CALLSIGN}); unset IFS;
        DXCC_FROM="${CUT_ARRAY[0]}"
        unset CUT_ARRAY
        IFS='-'; CUT_ARRAY=(${DXCC_FROM}); unset IFS;
        DXCC_FROM="${CUT_ARRAY[0]}"
        unset CUT_ARRAY

        # NOTE: The average time to resolve, calling dxcc.pl,
        # is 4-5 seconds on a Raspberry Pi Zero.  Loading
        # the script creates a lot of overhead.
        #
        # Callsigns found in either user.csv or ndxn.csv
        # can be resolved (and w/ greater detail) in fractions
        # of a second, which is why dxcc.pl is my last resort
        # to determine at least *some* QTH information.
        #
        # However, if I have to use dxcc.pl to resolve, I then
        # cache the result so that next time that callsign
        # appears, the country can be parsed from the cache
        # to save time... A LOT of time!  (The cache persists
        # until reboot.)
        DXCC_CACHE_RECORD="$(grep "^${DXCC_FROM}:" "${DXCC_CACHE_FILE}")"
        if [[ -n "${DXCC_CACHE_RECORD}" ]]
        then
          COUNTRY="${DXCC_CACHE_RECORD#*:}"
          DXCC_TIME="Cached"
        else
          # Capture both the "Country" resolved by dxcc.pl, AND the time it took to resolve.
          # This technique captures both STDOUT and STDERR, saving them both in variables.
          # With "TIMEFORMAT" defined earlier as "%R", the "time" command gives only the
          # "real" time, in seconds.
          {
            IFS=$'\n' read -r -d '' CAPTURED_STDERR;
            IFS=$'\n' read -r -d '' CAPTURED_STDOUT;
          } < <( (printf '\0%s\0' "$(time dxcc.pl "${DXCC_FROM}" | grep "^Country Name:" | awk '{ print substr($0, index($0,$3)) }')" 1>&2) 2>&1)
          #  ^--^--- These spaces are important for proper operation,
          #          and for syntax linting such as in "vim".
          COUNTRY="${CAPTURED_STDOUT}"
          DXCC_TIME="${CAPTURED_STDERR} secs"

          echo "${DXCC_FROM}:${COUNTRY}" >> "${DXCC_CACHE_FILE}"
        fi
      fi
    fi
  fi

  # If any fields came back empty, set a default of "n/a" (not available)
  CITY=${CITY:-'n/a'}
  STATE=${STATE:-'n/a'}
  COUNTRY=${COUNTRY:-'n/a'}

  #----------
  # Show location details
  if [[ "${CITY}" = "n/a" ]] && [[ "${STATE}" = "n/a" ]] && [[ "${COUNTRY}" = "n/a" ]]
  then
    if [[ "${USE_DXCC}" = "1" ]]
    then
      echo "${MAG}${BOLD}Unable to determine QTH or DXCC Country${SGR0}${WHI}${CLR_ED}"
    else
      echo "${MAG}DXCC Lookups Disabled on Cmdline${SGR0}${WHI}${CLR_ED}"
    fi
  else
    echo -en "${DIM}File:${SGR0} ${MAG}${BOLD}${QTH_SRC}${SGR0}${WHI}\r"
    tput cuf 18
    if [[ "${QTH_SRC}" = "cty.dat" ]]
    then
      echo "${DIM}QTH:${SGR0} ${MAG}${BOLD}${COUNTRY} (DXCC: ${DXCC_TIME})${SGR0}${WHI}${CLR_ED}"
    else
      echo "${DIM}QTH:${SGR0} ${MAG}${BOLD}${CITY}, ${STATE}, ${COUNTRY}${SGR0}${WHI}${CLR_ED}"
    fi
  fi

  fnQSO_IN_PROGRESS
}

#-----------------------------------
fnDMR_SHOW_CURRENT_CALL()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  #----------
  # Show our human-readable date/time
  echo -n "${DIM}Date:${SGR0} ${BLU}${BOLD}${DATE}${SGR0}${WHI}"
  tput cuf 11
  echo -n "${DIM}Time:${SGR0} ${BLU}${BOLD}${TIME}${SGR0}${WHI}"
  tput cuf 4
  echo -n "${DIM}QSOs Watched:${SGR0} ${BLU}${BOLD}${CLR_ED}"
  printf %05d "${QSO_COUNT}"
  echo "${SGR0}${WHI}${CLR_ED}"

  #----------
  # Show formatted to and from names
  P_FROM_NAME="$(printf "%-15s" "(${FROM_NAME})")"
  P_TO_NAME="$(printf "%-15s" "(${TO_NAME})")"
  echo -en "${DIM}From:${SGR0} ${BOLD}${FROM} ${P_FROM_NAME}${SGR0}\r"
  ((DMR_COUNT++))
  echo "${DMR_COUNT}" > "${DMR_COUNT_FILE}"

  tput cuf 31
  echo "${DIM} To..:${SGR0} ${BOLD}${TO} ${P_TO_NAME}${SGR0}${WHI}${CLR_ED}"

  #----------
  # Show DMR ID# (Best guess - see comment in function fnDMR_GET_FROM)
  if [[ -n "${FROM_ID}" ]]
  then
    DMR_ID="${FROM_ID}"
  else
    DMR_ID="${TO_ID}"
  fi

  #----------
  # Ok, we found the Callsign in the DMRIds.dat file.  Let's see
  # if the Callsign is associated with multiple DMR ID #s.
  if [[ "$(grep -c "${GTAB}${FROM}${GTAB}" "${DMRIDS}")" -gt 1 ]]
  then
    DMR_ID="${DMR_ID}(*)"
  fi
  echo -en "${DIM}ID #:${SGR0} ${MAG}${BOLD}${DMR_ID}${SGR0}${WHI}\r"
  tput cuf 18

  #----------
  # Show location details from the user.csv file
  if [[ "${CITY}" = "n/a" ]] && [[ "${STATE}" = "n/a" ]] && [[ "${COUNTRY}" = "n/a" ]]
  then
    echo "${MAG}${BOLD}No Location Data Found${SGR0}${WHI}${CLR_ED}"
  else
    # Another "empty" TA containing only blank spaces.  :/
    # Either put something useful in your TA, or don't bother using it.
    if echo "${CITY}${STATE}${COUNTRY}" | grep -q "[a-zA-Z]"
    then
      echo "${DIM}QTH:${SGR0} ${MAG}${BOLD}${CITY}, ${STATE}, ${COUNTRY}${SGR0}${WHI}${CLR_ED}"
    fi
  fi

  #----------
  # show the time slot, source (RF or network), and type (voice or data)
  echo -en "${DIM}Mode:${SGR0} ${CYA}${BOLD}DMR TS${TIME_SLOT}${SGR0}${WHI}\r"
  tput cuf 18
  echo -e "${DIM}Src:${SGR0} ${CYA}${BOLD}${SOURCE}${SGR0}${WHI}\t${DIM}Type:${SGR0} ${BOLD}${TYPE}${SGR0}${WHI}${CLR_ED}"

  fnQSO_IN_PROGRESS
}

#-----------------------------------
fnDMR_GET_NET_BER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # BER is in different positions, for network and RF log entries
  BER="$(echo "${RECORD}" | awk '{ print $NF }')"
  IFS='%'; CUT_ARRAY=(${BER}); unset IFS;
  BER="${CUT_ARRAY[0]}"
  unset CUT_ARRAY
}

#-----------------------------------
fnDMR_GET_RF_BER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # BER is in different positions, for network and RF log entries
  BER="$(echo "${RECORD}" | awk '{ print $21 }')"
  IFS=','; CUT_ARRAY=(${BER}); unset IFS;
  BER="${CUT_ARRAY[0]}"
  unset CUT_ARRAY
  IFS='%'; CUT_ARRAY=(${BER}); unset IFS;
  BER="${CUT_ARRAY[0]}"
  unset CUT_ARRAY
}

#-----------------------------------
fnCOLORIZE_BER()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # Default to Good/Green
  BER_COLOR="${GRE}"
  if [[ -n "$(echo "${BER}" | awk '$1 >=2.0{print}')" ]] && [[ -n "$(echo "${BER}" | awk '$1 <=4.9{print}')" ]]
  then
    # Fair
    BER_COLOR="${YEL}"
  else
    if [[ -n "$(echo "${BER}" | awk '$1 >=5.0{print}')" ]]
    then
      # Poor
      BER_COLOR="${RED}"
    fi
  fi
}

#-----------------------------------
fnDMR_GET_LOSS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # Get the packet loss
  LOSS="$(echo "${RECORD}" | cut -f4 -d"," | awk '{ print $1 }' | sed -u 's/%//')"
}

#-----------------------------------
fnCOLORIZE_LOSS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # Default to Good/Green
  LOSS_COLOR="${GRE}"
  if [[ -n "$(echo "${LOSS}" | awk '$1 >1.0{print}')" ]] && [[ -n "$(echo "${LOSS}" | awk '$1 <3.0{print}')" ]]
  then
    # Fair
    LOSS_COLOR="${YEL}"
  else
    if [[ -n "$(echo "${LOSS}" | awk '$1 >=3.0{print}')" ]]
    then
      # Poor
      LOSS_COLOR="${RED}"
    fi
  fi
}

#-----------------------------------
fnDMR_GET_RSSI()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # Get the RSSI
  RSSI="$(echo "${RECORD}" | awk '{ print $23 }')"
  IFS='/'; CUT_ARRAY=(${RSSI}); unset IFS;
  DBM="${CUT_ARRAY[0]}"
  unset CUT_ARRAY
  IFS='-'; CUT_ARRAY=(${DBM}); unset IFS;
  DBM="${CUT_ARRAY[1]}"
  unset CUT_ARRAY
}

#-----------------------------------
fnCOLORIZE_RSSI()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # What follows converts RSSI dBm to S-Meter values.
  # We look for S9 through S1 signal strength...
  # Very Strong
  SMETER_COLOR="${GRE}"
  if [[ "${DBM}" -lt 93 ]]
  then
    # If stronger than S9, calculate how much over
    SMETER="S9+$((93-DBM))dB"
  else
    # Good
    if [[ "${DBM}" -eq 93 ]]
    then
      SMETER="S9"
    else
      if [[ "${DBM}" -ge 99 ]] && [[ "${DBM}" -lt 93 ]]
      then
        SMETER="S8"
      else
        if [[ "${DBM}" -ge 85 ]] && [[ "${DBM}" -lt 105 ]]
        then
          SMETER="S7"
        else
          # Fair
          SMETER_COLOR="${YEL}"
          if [[ "${DBM}" -ge 105 ]] && [[ "${DBM}" -lt 111 ]]
          then
            SMETER="S6"
          else
            if [[ "${DBM}" -ge 111 ]] && [[ "${DBM}" -lt 117 ]]
            then
              SMETER="S5"
            else
              if [[ "${DBM}" -ge 117 ]] && [[ "${DBM}" -lt 123 ]]
              then
                SMETER="S4"
              else
                if [[ "${DBM}" -ge 123 ]] && [[ "${DBM}" -lt 129 ]]
                then
                  SMETER="S3"
                else
                  # Poor
                  SMETER_COLOR="${RED}"
                  if [[ "${DBM}" -ge 129 ]] && [[ "${DBM}" -lt 135 ]]
                  then
                    SMETER="S2"
                  else
                    if [[ "${DBM}" -ge 135 ]] && [[ "${DBM}" -lt 141 ]]
                    then
                      SMETER="S1"
                    else
                      # Things are REALLY bad, if you can't even reach S1 signal strength
                      if [[ "${DBM}" -ge 141 ]]
                      then
                        SMETER="S0"
                      fi
                    fi
                  fi
                fi
              fi
            fi
          fi
        fi
      fi
    fi
  fi
}

#-----------------------------------
fnDMR_TALKER_ALIAS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  # The log entries show that TA arrives in chunks.  Make sure we have
  # the whole thing before we print it.  Don't bother displaying, if
  # we don't get the whole thing (Kerchunkers, for example, don't
  # always connect long enough to transfer the whole TA.)
  # Also, sometimes, Talker Alias is present, but contains no data.
  # Don't bother showing if TA is empty or contains only partial data.
  TA_BYTES_RECVD="$(echo "${RECORD}" | grep "DMR Talker Alias" | cut -f1 -d"/" | awk '{ print $NF }')"
  TA_BYTES_TOTAL="$(echo "${RECORD}" | grep "DMR Talker Alias" | cut -f2 -d"/" | awk '{ print $1 }')"
  if [[ ${TA_BYTES_RECVD} -eq ${TA_BYTES_TOTAL} ]] && [[ ${TA_DISPLAYED} -eq 0 ]]
  then
    TA="$(echo "${RECORD}" | grep "DMR Talker Alias" | cut -f5- -d":" | sed -u -e "s/^ //" -e "s/'//g")"
    if [[ -n "${TA}" ]]
    then
      echo -en "\r${CLR_EL}"
      echo "${DIM}TA..:${SGR0} ${MAG}${BOLD}${TA}${SGR0}${WHI}${CLR_ED}"
      TA_DISPLAYED=1
      fnQSO_IN_PROGRESS
    fi
  fi
}

#-----------------------------------
fnDMR_DOWNLOAD_USERCSV()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # If the user.csv file is missing, or is older than 7 days,
  # then download a new one from the web.
  if [[ ! -f "${USERCSV}" ]] || [[ -n "$(find "${USERCSV}" -mtime +7)" ]] || [[ ${GET_CSV_NOW} -eq 1 ]]
  then
    echo -e "\nDownloading latest DMR user.csv file..."
    sudo mount -o remount,rw / 2>/dev/null
    if sudo wget -q --show-progress --progress=bar:force:noscroll https://database.radioid.net/static/user.csv -O "${USERCSV}.tmp"
    then
      echo "Applying the updated file..."
      if sudo mv "${USERCSV}.tmp" "${USERCSV}" && sudo chown pi-star.pi-star "${USERCSV}"
      then
        echo "Update complete."
      else
        echo "There was a problem applying the update.  Will continue without it." >&2
        sleep 2
      fi
    else
      echo "Unable to retrieve latest user.csv.  Will continue without it." >&2
      sleep 2
    fi
    sync;sync;sync
    sudo mount -o remount,ro / 2>/dev/null
  fi
}

#-----------------------------------
fnYSF_DOWNLOAD_CTYDAT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # If the cty.dat file is missing, or is older than 30 days,
  # then download a new one from the web.
  if [[ ! -f "${CTYDAT}" ]] || [[ -n "$(find "${CTYDAT}" -mtime +30)" ]] || [[ ${GET_DAT_NOW} -eq 1 ]]
  then
    echo -e "\nDownloading latest DXCC cty.dat file..."
    sudo mount -o remount,rw / 2>/dev/null

    BIGCTYZIP="$(curl -s "https://www.country-files.com/category/big-cty/" | grep "\[download\]" | sort -nr | head -1 | cut -f2 -d"\"")"
    if [[ -n "${BIGCTYZIP}" ]]
    then
      mkdir /tmp/bigctydir 2>/dev/null
      if sudo wget -q --show-progress --progress=bar:force:noscroll "${BIGCTYZIP}" -O "/tmp/bigctydir/bigcty.zip"
      then
        echo "Applying the updated file..."
        sudo unzip /tmp/bigctydir/bigcty.zip -d /tmp/bigctydir > /dev/null 2>&1
        if sudo cp /tmp/bigctydir/cty.dat "${CTYDAT}" && sudo chown pi-star.pi-star "${CTYDAT}"
        then
          sudo rm -r /tmp/bigctydir 2>/dev/null
          echo "Update complete."
        else
          echo "There was a problem applying the update.  Will continue without it." >&2
          sleep 2
        fi
      else
        echo "Unable to retrieve latest cty.dat.  Will continue without it." >&2
        sleep 2
      fi
      sync;sync;sync
      sudo mount -o remount,ro / 2>/dev/null
    else
      echo "Unable to determine latest available cty.dat.  Will continue without it." >&2
      sleep 2
    fi
  fi
}

#-----------------------------------
fnBUILD_HISTORY()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  if [[ -n "${FROM}" ]]
  then
    if [[ -n "${LOSS}" ]] || [[ -n "${BER}" ]] || [[ ${DATA} -eq 1 ]]
    then
      FROM="${FROM:0:10}"
      if [[ ${#FROM} -gt 10 ]]
      then
        FROM="${FROM}*"
      fi

      HIST_COUNT=${HIST_MAX}
      until [[ ${HIST_COUNT} -eq 0 ]]
      do
        HISTORY[HIST_COUNT]="${HISTORY[$((HIST_COUNT - 1))]}"
        ((HIST_COUNT--))
      done

      #----------
      HIST_TIME="$(printf %-8s "$(echo "${QSO_START_TIME}" | awk '{ print $1 }')")"
      HIST_FROM="$(printf %-10s "${FROM}")"
      HIST_TO="$(printf %-10s "${TO}")"
      HIST_SECS="$(printf %5s "${SECS}")"
      HIST_BER="$(printf %4s "${BER}")%"
      HIST_LOSS="$(printf %3s "${LOSS}")%"
      if [[ "${SOURCE}" = "NET" ]]
      then
        HIST_SRC="$(printf %-3s "Net")"
        HIST_SMETER=""
      else
        HIST_SRC="$(printf %-3s "RF")"
        HIST_SMETER="${SMETER} (-${DBM} dBm)"
      fi

      #----------
      if [[ ${DATA} -eq 1 ]]
      then
        HIST_SECS="-----"
        HIST_BER="-----"
      fi

      #----------
      if [[ "${LOGREC_MODE}" = "YSF" ]]
      then
        HIST_COLOR="${YEL}"
      else
        HIST_COLOR="${WHI}"
      fi

      #----------
      HISTORY[1]="${BOLD}${BLU}${HIST_TIME}${WHI}${SGR0} ${SBOX_VL} ${BOLD}${HIST_COLOR}${HIST_FROM}${SGR0} ${SBOX_VL} ${BOLD}${HIST_COLOR}${HIST_TO}${SGR0} ${SBOX_VL} ${BOLD}${BLU}${HIST_SECS}${WHI}${SGR0} ${SBOX_VL} ${BOLD}${BER_COLOR}${HIST_BER}${WHI}${SGR0} ${SBOX_VL} ${BOLD}${CYA}${HIST_SRC}${WHI}"

      #----------
      if [[ ${DATA} -eq 1 ]]
      then
        HISTORY[1]="${HISTORY[1]} ${SBOX_VL} ${BOLD}${YEL}Data Blocks: ${BLOCKS}${WHI}${SGR0}"
      else
        if [[ -n "${RSSI}" ]]
        then
          HISTORY[1]="${HISTORY[1]} ${SBOX_VL} ${BOLD}${SMETER_COLOR}${HIST_SMETER}${WHI}${SGR0}"
        else
          HISTORY[1]="${HISTORY[1]} ${SBOX_VL} ${BOLD}${LOSS_COLOR}${HIST_LOSS}${WHI}${SGR0}"
        fi
      fi
    fi
  fi
  #----------
  TIME=""
  FROM=""
  TO=""
  SECS=""
  BER=""
  LOSS=""
  SMETER=""
  DBM=""
  RSSI=""
  DATA=""
}

#-----------------------------------
fnTALLY_ERRORS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  ERROR_MSG="$(echo "${RECORD}" | cut -f4- -d" ")"

  ((ERROR_COUNT++))
  echo "${ERROR_COUNT}" > "${ERROR_COUNT_FILE}"

  # If we've masked the reporting of logged errors by
  # using the "-e|--error" cmdline option, then
  # skip displaying the error, but still tally it.
  if [[ "${SHOW_LOG_ERRORS}" = "1" ]]
  then
    echo "${SGR0}${YEL}"
    fnSEPARATOR

    echo -en "${BOLD}${RED}ERROR: ${WHI}${ERROR_MSG}\r"
    tput cuf 63
    echo "${BOLD}${RED} Count: $(printf %05d "${ERROR_COUNT}")"

    echo -n "${SGR0}${YEL}"
    fnSEPARATOR
  fi
}

#-----------------------------------
fnTALLY_WARNINGS()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  WARNING_MSG="$(echo "${RECORD}" | cut -f4- -d" ")"

  ((WARNING_COUNT++))
  echo "${WARNING_COUNT}" > "${WARNING_COUNT_FILE}"

  # Unlike errors, warnings will not be masked by
  # the "-e|--error" cmdline option.  They will
  # always be displayed (as well as tallied.)
  echo "${SGR0}${RED}"
  fnSEPARATOR

  echo -en "${BOLD}${RED}WARNING: ${WHI}${WARNING_MSG}\r"
  tput cuf 63
  echo "${BOLD}${RED} Count: $(printf %05d "${WARNING_COUNT}")"

  echo -n "${SGR0}${RED}"
  fnSEPARATOR
}

#-----------------------------------
fnDMR_MAIN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  #----------
  if [[ "${LOGREC_REMAINING_DATA}" =~ "DMR Talker Alias" ]]
  then
    fnDMR_TALKER_ALIAS
  else
    fnCONVERT_DATE_TIME

    # Determine DMR Time Slot, and RF or Network traffic
    TIME_SLOT="$(echo "${RECORD}" | awk '{ print $6 }')"
    TIME_SLOT="${TIME_SLOT%,*}"

    SOURCE="$(echo "${RECORD}" | awk '{ print $8 }')"
    SOURCE="${SOURCE//network/NET}"

    # Compensate for shifting fields between "group" and "private" ID numbers
    fnDMR_PAD_ABSENT_TG

    #----------
    if [[ "${LOGREC_REMAINING_DATA}" =~ "voice header" ]] || [[ ${LOGREC_REMAINING_DATA} = "data header" ]]
    then
      ((QSO_COUNT++))
      echo "${QSO_COUNT}" > "${QSO_COUNT_FILE}"

      # A QSO has started...
      QSO_START_TIME="${TIME}"
      fnDMR_GET_FROM
      fnDMR_GET_TO
      echo -en "\r${CLR_EL}"
      fnBANNER
      fnDMR_GET_VOICE_OR_DATA
      fnDMR_SHOW_CURRENT_CALL
    else
      # The QSO has ended.
      # If it was voice traffic...
      if [[ "${LOGREC_REMAINING_DATA}" =~ "end of voice" ]]
      then
        DATA=0

        # The number of seconds the contact lasted
        SECS="$(echo "${RECORD}" | awk '{ print $18 }')"

        # If it was network traffic...
        if [[ "${LOGREC_REMAINING_DATA}" =~ "RSSI:" ]]
        then
          # Else, for RF traffic...
          fnDMR_GET_RF_BER
          fnCOLORIZE_BER
          fnDMR_GET_RSSI
          fnCOLORIZE_RSSI

          echo -en "\r${CLR_EL}"
          echo -en "\r${DIM}Dur.:${SGR0} ${BLU}${BOLD}${SECS}${SGR0}${WHI}${DIM}sec\r"
          tput cuf 18
          echo -en "${DIM}BER:${SGR0} ${BER_COLOR}${BOLD}${BER}%${SGR0}${WHI}\t${DIM}RSSI:${SGR0} ${SMETER_COLOR}${BOLD}${SMETER} (-${DBM} dBm)${SGR0}${WHI}\r"
        else
          fnDMR_GET_NET_BER
          fnCOLORIZE_BER
          fnDMR_GET_LOSS
          fnCOLORIZE_LOSS

          echo -en "\r${CLR_EL}"
          echo -en "\r${DIM}Dur.:${SGR0} ${BLU}${BOLD}${SECS}${SGR0}${WHI} sec\r"
          tput cuf 18
          echo -en "${DIM}BER:${SGR0} ${BER_COLOR}${BOLD}${BER}%${SGR0}${WHI}\t${DIM}Loss:${SGR0} ${LOSS_COLOR}${BOLD}${LOSS}%${SGR0}${WHI}\r"
        fi

        # If call was less than 2 secs,
        # and we know who it was from,
        # then call it a kerchunk.
        # Responses such as "disconnected",
        # received with a 4000 disconnect
        # are not counted.
        if [[ -n "${FROM}" ]] && [[ -n "$(echo "${SECS}" | awk '$1 <2.0{print}')" ]]
        then
          ((KERCHUNK_COUNT++))
          echo "${KERCHUNK_COUNT}" > "${KERCHUNK_COUNT_FILE}"
          tput cuf 64
          echo "${YEL}[[kerchunk]]${SGR0}${WHI}"
        else
          echo
        fi
      else
        # It was data traffic...
        DATA=1

        if [[ "${LOGREC_REMAINING_DATA}" =~ "ended network data" ]] || [[ "${LOGREC_REMAINING_DATA}" =~ "ended RF data" ]]
        then
          if [[ ${BLOCKS} -gt 1 ]]
          then
            S="s"
          else
            S=""
          fi
          echo -e "\r${CLR_EL}${YEL}${BOLD}End of Data Transmission (${BLOCKS} block${S})${SGR0}${WHI}"
        fi
      fi

      fnBUILD_HISTORY
      echo -n "${BLU}"
      fnSEPARATOR
      fnLISTENING
    fi
  fi
}

#-----------------------------------
fnYSF_MAIN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  #----------
  # Start of YSF network traffic
  if [[ "${LOGREC_REMAINING_DATA}" =~ "received network data from" ]]
  then
    fnCONVERT_DATE_TIME
    QSO_START_TIME="${TIME}"

    if [[ "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $7 }')" = "to" ]]
    then
      read -r LOGREC_CALLSIGN  LOGREC_DG_ID  LOGREC_DG_ID_NUM  LOGREC_MASTER \
        <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $6 " " $8 " " $9 " " $11 }')"
    else
      # This drops space-separated values from the transmitted callsigns.
      read -r LOGREC_CALLSIGN  LOGREC_DG_ID  LOGREC_DG_ID_NUM  LOGREC_MASTER \
        <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $6 " " $9 " " $10 " " $12 }')"
    fi

    FROM="${LOGREC_CALLSIGN}"
    TO="${LOGREC_DG_ID} ${LOGREC_DG_ID_NUM}"
    echo -en "\r${CLR_EL}"
    fnBANNER

    SOURCE="NET"

    ((QSO_COUNT++))
    echo "${QSO_COUNT}" > "${QSO_COUNT_FILE}"
    fnYSF_SHOW_CURRENT_CALL
    return
  fi

  #----------
  # Start of YSF RF traffic
  if [[ "${LOGREC_REMAINING_DATA}" =~ "received RF header from" ]] || [[ "${LOGREC_REMAINING_DATA}" =~ "received RF late entry from" ]]
  then
    fnCONVERT_DATE_TIME
    QSO_START_TIME="${TIME}"

    if [[ "${LOGREC_REMAINING_DATA}" =~ "received RF header from" ]]
    then
      # Parse Recvd RF header...
      if [[ "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $7 }')" = "to" ]]
      then
        read -r LOGREC_CALLSIGN  LOGREC_DG_ID  LOGREC_DG_ID_NUM \
          <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $6 " " $8 " " $9 }')"
      else
        # This drops space-separated values from the transmitted callsigns.
        read -r LOGREC_CALLSIGN  LOGREC_DG_ID  LOGREC_DG_ID_NUM \
          <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $6 " " $8 " " $10 }')"
      fi
    else
      # Parse RF late entries...
      if [[ "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $8 }')" = "to" ]]
      then
        read -r LOGREC_CALLSIGN  LOGREC_DG_ID  LOGREC_DG_ID_NUM \
          <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $7 " " $9 " " $10 }')"
      else
        # This drops space-separated values from the transmitted callsigns.
        read -r LOGREC_CALLSIGN  LOGREC_DG_ID  LOGREC_DG_ID_NUM \
          <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $7 " " $9 " " $11 }')"
      fi
    fi

    FROM="${LOGREC_CALLSIGN}"
    TO="${LOGREC_DG_ID} ${LOGREC_DG_ID_NUM}"
    echo -en "\r${CLR_EL}"
    fnBANNER

    SOURCE="RF"

    ((QSO_COUNT++))
    echo "${QSO_COUNT}" > "${QSO_COUNT_FILE}"
    fnYSF_SHOW_CURRENT_CALL
    return
  fi

  #----------
  # YSF RF traffic dropped
  # transmission lost from KE8DPF     to ALL       , 1.6 seconds, BER: 0.8%, RSSI: -58/-47/-47 dBm
  # similar to: "received RF end of transmission from KE8DPF     to DG-ID 0, 1.0 seconds, BER: 0.8%, RSSI: -55/-51/-52 dBm"
  if [[ "${LOGREC_REMAINING_DATA}" =~ "transmission lost from" ]]
  then
    read -r LOGREC_SECS  LOGREC_BER  LOGREC_RSSI \
      <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $9 " " $12 " " $14 }')"
    if [[ "${LOGREC_RSSI}" = "" ]]
    then
      LOGREC_RSSI="${LOGREC_BER}"
      LOGREC_BER="0.0%"
    fi

    LOGREC_DG_ID_NUM="${LOGREC_DG_ID_NUM%,*}"

    LOGREC_BER="${LOGREC_BER%,*}"

    # Fields to pass to the history...
    SECS="${LOGREC_SECS}"
#   BER="$(echo "${LOGREC_BER}" | cut -f1 -d"%")"
#   BER="${LOGREC_BER%"%"*}"
    IFS='%'; CUT_ARRAY=(${LOGREC_BER}); unset IFS;
    BER="${CUT_ARRAY[0]}"
    unset CUT_ARRAY

    RSSI="${LOGREC_RSSI}"
    IFS='/'; CUT_ARRAY=(${RSSI}); unset IFS;
    DBM="${CUT_ARRAY[0]}"
    unset CUT_ARRAY
    IFS='-'; CUT_ARRAY=(${DBM}); unset IFS;
    DBM="${CUT_ARRAY[1]}"
    unset CUT_ARRAY

    fnCOLORIZE_BER
    fnCOLORIZE_RSSI

    #----------
    echo -en "\r${CLR_EL}"
    echo -e "\r${BOLD}${YEL}TRANSMISSION LOST${SGR0}${WHI}"
    echo -en "\r${DIM}Dur.:${SGR0} ${BLU}${BOLD}${LOGREC_SECS}${SGR0}${WHI} sec\r"
    tput cuf 18
    echo -en "${DIM}BER:${SGR0} ${BER_COLOR}${BOLD}${LOGREC_BER}${SGR0}${WHI}\r"
    tput cuf 32
    echo -en "${DIM}RSSI:${SGR0} ${SMETER_COLOR}${BOLD}${SMETER} (-${DBM} dBm)${SGR0}${WHI}\r"

    if [[ -n "${FROM}" ]] && [[ -n "$(echo "${SECS}" | awk '$1 <2.0{print}')" ]]
    then
      ((KERCHUNK_COUNT++))
      echo "${KERCHUNK_COUNT}" > "${KERCHUNK_COUNT_FILE}"
      tput cuf 64
      echo "${YEL}[[kerchunk]]${SGR0}${WHI}"
    else
      echo
    fi
    echo -n "${CLR_ED}"

    fnBUILD_HISTORY
    echo -n "${MAG}"
    fnSEPARATOR
    fnLISTENING
    return
  fi

  #----------
  # End of YSF network traffic (Wires-X)
  if [[ "${LOGREC_REMAINING_DATA}" =~ "received network end of transmission from" ]]
  then
    read -r LOGREC_SECS  LOGREC_LOSS  LOGREC_BER \
      <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $12 " " $14 " " $18 }')"
    fnYSF_END_NETWORK_TRAFFIC
    return
  fi
  # End of YSF network traffic (Normal traffic)
  if [[ "${LOGREC_REMAINING_DATA}" =~ "network watchdog has expired" ]]
  then
    read -r LOGREC_SECS  LOGREC_LOSS  LOGREC_BER \
      <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $6 " " $8 " " $12 }')"
    fnYSF_END_NETWORK_TRAFFIC
    return
  fi

  #----------
  # End of YSF RF traffic
  if [[ "${LOGREC_REMAINING_DATA}" =~ "received RF end of transmission from" ]]
  then
    read -r LOGREC_SECS  LOGREC_BER  LOGREC_RSSI \
      <<< "$(echo "${LOGREC_REMAINING_DATA}" | awk '{ print $12 " " $15 " " $17 }')"
    if [[ "${LOGREC_RSSI}" = "" ]]
    then
      LOGREC_RSSI="${LOGREC_BER}"
      LOGREC_BER="0.0%"
    fi

    LOGREC_DG_ID_NUM="${LOGREC_DG_ID_NUM%,*}"

    LOGREC_BER="${LOGREC_BER%,*}"

    # Fields to pass to the history...
    SECS="${LOGREC_SECS}"
#   BER="$(echo "${LOGREC_BER}" | cut -f1 -d"%")"
#   BER="${LOGREC_BER%"%"*}"
    IFS='%'; CUT_ARRAY=(${LOGREC_BER}); unset IFS;
    BER="${CUT_ARRAY[0]}"
    unset CUT_ARRAY

    RSSI="${LOGREC_RSSI}"
    IFS='/'; CUT_ARRAY=(${RSSI}); unset IFS;
    DBM="${CUT_ARRAY[0]}"
    unset CUT_ARRAY
    IFS='-'; CUT_ARRAY=(${DBM}); unset IFS;
    DBM="${CUT_ARRAY[1]}"
    unset CUT_ARRAY

    fnCOLORIZE_BER
    fnCOLORIZE_RSSI

    echo -en "\r${CLR_EL}"
    echo -en "\r${DIM}Dur.:${SGR0} ${BLU}${BOLD}${LOGREC_SECS}${SGR0}${WHI} sec\r"
    tput cuf 18
    echo -en "${DIM}BER:${SGR0} ${BER_COLOR}${BOLD}${LOGREC_BER}${SGR0}${WHI}\r"
    tput cuf 32
    echo -en "${DIM}RSSI:${SGR0} ${SMETER_COLOR}${BOLD}${SMETER} (-${DBM} dBm)${SGR0}${WHI}\r"

    if [[ -n "${FROM}" ]] && [[ -n "$(echo "${SECS}" | awk '$1 <2.0{print}')" ]]
    then
      ((KERCHUNK_COUNT++))
      echo "${KERCHUNK_COUNT}" > "${KERCHUNK_COUNT_FILE}"
      tput cuf 64
      echo "${YEL}[[kerchunk]]${SGR0}${WHI}"
    else
      echo
    fi

    fnBUILD_HISTORY
    echo -n "${MAG}"
    fnSEPARATOR
    fnLISTENING
    return
  fi
}

#-----------------------------------
fnNXDN_MAIN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  echo -n "${DIM}${WHI}"
  fnSEPARATOR
  echo "NXDN log entry..."
  echo "${RECORD}"
  fnSEPARATOR
}

#-----------------------------------
fnDSTAR_MAIN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  echo -n "${DIM}${WHI}"
  fnSEPARATOR
  echo "DSTAR log entry..."
  echo "${RECORD}"
  fnSEPARATOR
}

#-----------------------------------
fnP25_MAIN()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  trap fnWINCH WINCH

  echo -n "${DIM}${WHI}"
  fnSEPARATOR
  echo "P25 log entry..."
  echo "${RECORD}"
  fnSEPARATOR
}

#-----------------------------------
fnMAIN_LOOP()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

#KPC
  if [[ ${REPLAY} -eq 0 ]]
  then
    CMD="tail -f -n 1"
  else
    CMD="cat"
  fi

  eval "${CMD}" "${WORKING_LOG}" 2>/dev/null | grep -E --line-buffered " DMR | YSF,| D-Star| NXDN| P25|MMDVMHOST-STOP|SIGTERM" \
    | grep -v -E --line-buffered "^D:|^I:|0000:|Opening|Closing|Embedded" \
    | while read -r RECORD
  do
    #----------
    # See if MMDVMHost has either shutdown, or transitioned to a new log.
    if [[ "${RECORD}" =~ "MMDVMHOST-STOP" ]] || [[ "${RECORD}" =~ "SIGTERM" ]]
    then
#KPC
      if [[ ${REPLAY} -eq 0 ]]
      then
        # If it did, it has triggered our exit from the loop.
        # We appended an additional blank line into the log, so that when
        # the "tail -f -n 1" next restarts against the log, the trigger
        # will have receeded far enough back to not cause a false restart
        # of this script.
        # Once we've caught the trigger, kill the tail that drives the loop.
        TAIL_PID="$(sudo fuser -v "${WORKING_LOG}" 2>&1 | grep "tail" | awk '{ print $2 }')"
        kill "${TAIL_PID}" 2>/dev/null
        return
      fi
    fi

    #----------
    # The MMDVMHost daemon logs any errors or warnings it encounters.
    # Errors are logged in records beginning with "E:".
    # Warnings are logged in records beginning with "W:".
    # FYI: Debug messages are logged in records beginning with "D:".
    # FYI: Information messages are logged in records beginning with "I:".
    # FYI: Modem Traffic messages are logged in records beginning with "M:".
    LOGREC_TYPE="${RECORD:0:2}"
    case "${LOGREC_TYPE}" in
      "E:")
        fnTALLY_ERRORS
        continue
        ;;
      "W:")
        fnTALLY_WARNINGS
        continue
        ;;
      "M:")
        read -r LOGREC_DATE LOGREC_TIME LOGREC_MODE <<< "$(echo "${RECORD}" | awk '{ print $2 " " $3 " " $4 }')"
        LOGREC_MODE="${LOGREC_MODE%,*}"
        # Grab everything that follows the mode...
        read -r LOGREC_REMAINING_DATA <<< "$(echo "${RECORD}" | awk '{ print substr($0, index($0,$4)) }')"
        ;;
      *)
        continue
        ;;
    esac

    #----------
    case "${LOGREC_MODE}" in
      "YSF")
        fnYSF_MAIN
        ;;
      "DMR")
        fnDMR_MAIN
        ;;
      "NXDN")
        fnNXDN_MAIN
        ;;
      "D-Star")
        fnDSTAR_MAIN
        ;;
      "P25")
        fnP25_MAIN
        ;;
    esac
  done
}

#-----------------------------------
fnABORT()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  fnRESET_SCROLLING

  # Clear the bottom line of the screen
  tput cup "${LINES}" 0
  echo -en "\r${CLR_EL}"

  # Re-Enable line-wrap, turn the cursor on, reset the terminal,
  # and switch back to the primary screen buffer
  echo -n "${WRAP_ON}${CUR_ON}${SGR0}${RMCUP}"

  if [[ ${HAS_BUFFER} -eq 0 ]]
  then
    fnLOGO
  fi

  fnGOODBYE_BOX
  tput cup "${LINES}" 0

  fnCLEANUP
  fnCLOSE_FDS
  # If debugging and/or profiling was used, show the names of the logs, at exit
  if [[ "${DEBUG_LOG}" != "/dev/null" ]] || [[ "${PROFILING_LOG}" != "/dev/null" ]]
  then
    if [[ "${MY_FONT}" = "5" ]]
    then
      DEBUG_PROFILING_LINE=$((LINES - 6))
    else
      DEBUG_PROFILING_LINE=$((LINES - 4))
    fi
    tput cup "${DEBUG_PROFILING_LINE}" 0
    fnLARGE_FONT "DEBUGGING: ${DEBUG_LOG}"
    fnLARGE_FONT "PROFILING: ${PROFILING_LOG}"
    echo
  fi

  tput cup "${LINES}" 0
  echo -en "${TERM_RESET}"
  exit
}

#-----------------------------------
fnWINCH()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # Get the screensize.  We'll be needing the number of lines.
  read -r LINES COLUMNS <<< "$(python3 -c "${PY3_SCRIPT}")" 2>/dev/null
  tput csr 0 $((LINES - 1))
  clear

  if [[ ${TOP} -eq 1 ]]
  then
    tput cup "${BELOW_NOSCROLL}" 0
    fnNOSCROLL_ZONE
    # Clear to end of display
    echo -n "${CLR_ED}"
  fi
}

#-----------------------------------
fnLOAD_HISTORY_FILE()
{
  echo -e "\nenter: ${FUNCNAME[*]}" >&3

  # If we are auto-restarting, load the previous history...
  if [[ -f "${HISTORY_FILE}" ]]
  then
    # shellcheck disable=SC1090
    . "${HISTORY_FILE}"

    # Push them all down the list, one position.
    HIST_COUNT=${HIST_MAX}
    until [[ ${HIST_COUNT} -eq 0 ]]
    do
      HISTORY[HIST_COUNT]="${HISTORY[$((HIST_COUNT - 1))]}"
      ((HIST_COUNT--))
    done
    # Insert a restart marker as the most recent history entry
    HISTORY[1]="${CYA}$(date +%H:%M:%S) ${SGR0}${WHI}${SBOX_VL} ---------- ${SBOX_VL} ---------- ${SBOX_VL} ----- ${SBOX_VL} ----- ${SBOX_VL} --- ${SBOX_VL}${CYA} ${BOUNCE_MSG} ${SGR0}${WHI}"
  fi
}

###########################################################
# A few last items in the pre-flight checklist...

# If user presses Ctrl-C, stop the program
trap fnABORT SIGINT SIGTERM

trap fnCLEANUP EXIT

# Check for any options passed to the script.
if [[ -n "${ARG_LIST[0]}" ]]
then
  fnPARSE_CMDLINE
fi

# Make sure we have an updated user.csv file
fnDMR_DOWNLOAD_USERCSV

# Make sure we have an updated cty.dat file
fnYSF_DOWNLOAD_CTYDAT

fnDEFINE_BOXCHARS

if [[ ${LOGO} -eq 1 ]]
then
  fnLOGO
  tput cup 22 2
else
  fnNO_LOGO
fi

#KPC
# If running normally (not in replay mode)... ensure that
# MMDVMHost is running, and that it is writing to the log.
if [[ ${REPLAY} -eq 0 ]]
then
  echo -en "\r${CLR_EL}${SGR0}${WHI}Checking MMDVMHost... "
  if [[ "$(pgrep -f "/usr/local/bin/MMDVMHost /etc/mmdvmhost")" = "" ]]
  then
    echo -e "\n  ${RED}MMDVMHost is NOT RUNNING.${SGR0}" >&2
    echo -e "  Check status in the pi-star GUI and try again.\n" >&2
    exit
  else
    if [[ ! "$(sudo fuser -v "${WORKING_LOG}" 2>&1)" =~ "MMDVMHost" ]]
    then
      echo -e "\n  ${YEL}MMDVMHost is running, but is NOT writing to $(basename "${WORKING_LOG}").${SGR0}" >&2
      echo -e "  Check status in the pi-star GUI and try again.\n" >&2
      exit
    fi
  fi
  sleep .5
fi

# Fetch the version number from what's posted on github.
# Compare that version number with what is currently running.
# If github has a later version, tell the user.
echo -en "\r${CLR_EL}${SGR0}${WHI}Performing Version Check... "
VER_CHECK_COLOR="${WHI}${BOLD}"
VER_CHECK="$(curl -s https://raw.githubusercontent.com/kencormack/pistar-lastqso/main/pistar-lastqso 2>/dev/null | grep "^VERSION=")"
VER_CHECK="${VER_CHECK#*=}"

IS_DEV=""
if fnCOMPARE_FLOAT_GT "${VERSION}" "${VER_CHECK}" | grep -q ">"
then
  IS_DEV="*"
fi

# See if the user is running a version older than the latest available
if fnCOMPARE_FLOAT_LT "${VERSION}" "${VER_CHECK}" | grep -q "<"
then
  echo -e "\r${GRE}${BOLD}AN UPDATE TO THIS SCRIPT IS AVAILABLE AT:"
  echo "${GRE}${DIM}https://github.com/kencormack/pistar-lastqso"
  echo "${WHI}${DIM}    Your Version: ${VERSION}${SGR0}"
  echo -e "${WHI}${BOLD}Available Update: ${VER_CHECK}${SGR0}${WHI}\n"
  VER_CHECK_COLOR="${RED}"
  sleep 3
fi

echo -en "\r${CLR_EL}${SGR0}${WHI}Checking Active Modes... "
fnGET_MODES
fnCHECK_MODES_ENABLED
sleep .5

echo -en "\r${CLR_EL}${SGR0}${WHI}Initializing... "
sleep .5

# These will store the history to be displayed, if the
# no-scroll region is called upon.
if [[ ${TOP} = 1 ]]
then
  # Start with a fresh history...
  HIST_COUNT=1
  until [[ ${HIST_COUNT} -gt ${HIST_MAX} ]]
  do
    HISTORY[HIST_COUNT]="         ${SBOX_VL}            ${SBOX_VL}            ${SBOX_VL}       ${SBOX_VL}       ${SBOX_VL}     ${SBOX_VL}${SGR0}${WHI}"
    ((HIST_COUNT++))
  done
fi

# collect the data for the no-scroll region
fnTOP_DATA

echo -en "\r${CLR_EL}${SMCUP}"
echo -n "${CUR_HOME}"

if [[ ${TOP} -eq 1 ]]
then
  fnNOSCROLL_ZONE
  tput cup "${BELOW_NOSCROLL}" 0
  echo -n "${CLR_ED}"
fi

# By the time we've drawn the no-scroll zone, we've already
# created a history file with a logging restart record.  Since
# I want to start with a "clean" display, I'll delete the file
# (thus it's "Watching Log" record) here.  The log restart
# entry will be added once the loop that follows gets started,
# after any QSOs are added and logging pauses/resumes.
rm "${HISTORY_FILE}" 2>/dev/null

# Make the named function available for execution as a
# seperate job that can be run in the background.
export -f fnMMDVMLOG_FUSER

###########################################################
# Now for the meat and potatoes...
while true
do
  #===============
  # Read in the counter values
  DMR_COUNT=$(< "${DMR_COUNT_FILE}")
  YSF_COUNT=$(< "${YSF_COUNT_FILE}")
  QSO_COUNT=$(< "${QSO_COUNT_FILE}")
  KERCHUNK_COUNT=$(< "${KERCHUNK_COUNT_FILE}")
  ERROR_COUNT=$(< "${ERROR_COUNT_FILE}")
  WARNING_COUNT=$(< "${WARNING_COUNT_FILE}")

  fnLOAD_HISTORY_FILE

#KPC
  #----------
  if [[ ${REPLAY} -eq 0 ]]
  then
    # This forks fnMMDVMLOG_FUSER into the background as a child process.
    # It runs "fuser" against the log.  If "MMDVMHost" no longer shows
    # in the output, then MMDVMHost is no longer writing to the log.  The
    # function then appends "MMDVMHOST-STOP" to the log file.  The "read" in
    # fnMAIN_LOOP will spot this and will act on it, to re-launch the script.
    #
    # If the background job is already running, don't spawn another copy.
    if [[ "$(pgrep -f "/bin/bash -c fnMMDVMLOG_FUSER")" = "" ]]
    then
      /bin/bash -c fnMMDVMLOG_FUSER > /dev/null 2>&1 &
      BG_PID="$(pgrep -o -f "/bin/bash -c fnMMDVMLOG_FUSER")"
    fi
  fi

  #----------
  fnLISTENING

  # And here we go...
  # set -x
  fnMAIN_LOOP
  # set +x

  #===============
  # If we've exited fnMAIN_LOOP, it's because MMDVMHost is no longer writing
  # to the log that we've been watching.  Either the service was stopped
  # during pi-star's nightly update, or it has rolled to a new day's log.
  # Watch for new log activity, then resume watching QSOs.
  echo -e "\n\n${RED}${DBL_LINE}${WHI}${SGR0}${CLR_EL}"
  echo "${RED}$(basename "${WORKING_LOG}") LOG ACTIVITY HAS STOPPED.${WHI}${SGR0}"
  echo -n "${YEL}WATCHING FOR NEW LOG ACTIVITY...${WHI}${SGR0} "

#KPC
  #===============
  if [[ ${REPLAY} -eq 1 ]]
  then
    if [[ ! "$(sudo fuser -v "${WORKING_LOG}" 2>&1)" =~ "cat" ]]
    then
      echo "${BOLD}${WHI}"
      fnSEPARATOR
      fnSEPARATOR
      echo -n "${SGR0}${GRE}"
      figlet -w 80 -f ansi_shadow "COMPLETE"
      echo -n "${BOLD}${WHI}"
      tput cuu1
      fnSEPARATOR
      fnSEPARATOR
      echo -n "${SGR0}${DEF}"
      exit
    fi
  fi

  #----------
  OLD_LOG="${WORKING_LOG}"
  while [[ ! "$(sudo fuser -v "${WORKING_LOG}" 2>&1)" =~ "MMDVMHost" ]]
  do
    sleep 2
    # Make sure we're working with latest log.
    CANDIDATE_FILES=("${LOGDIR}/${LOGROOT}"*.log) NEWEST=${CANDIDATE_FILES[0]}
    for F in "${CANDIDATE_FILES[@]}"
    do
      if [[ "${F}" -nt "${NEWEST}" ]]
      then
        NEWEST="${F}"
      fi
    done
    WORKING_LOG="${NEWEST}"
  done
  echo -e "\n${GRE}LOG ACTIVITY HAS RESUMED USING $(basename "${WORKING_LOG}")...${WHI}${SGR0}"

  #----------
  if [[ "${OLD_LOG}" != "${WORKING_LOG}" ]]
  then
    echo "${GRE}${DIM}Daily MMDVM log rotation detected.${WHI}${SGR0}"
    BOUNCE_MSG="- LOG ROTATION -"
  else
    echo "${GRE}${DIM}Service bounce detected (pi-star update, user reconfig, or other restart.)${WHI}${SGR0}"
    BOUNCE_MSG="-SVCS RESTARTED-"
  fi

  #----------
  # Reexamine the activated modes, in case the log was bounced due to
  # user configuration changes made in the GUI's "Configuration" page.
  fnGET_MODES

  #----------
  # Reexamine other details (such as log name, Master Servers, etc.),
  # in case any values shown in the no-scroll zone have changed.
  fnTOP_DATA
  fnNOSCROLL_ZONE

  echo -e "${GRE}${DBL_LINE}${WHI}${SGR0}${CLR_EL}\n"

  ((LOG_RESTARTS++))
done
